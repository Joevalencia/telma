<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>telma API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>telma</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from time import strftime
import requests
import json
import warnings

send_url = &#34;http://ipinfo.io&#34;
geo_req = requests.get(send_url)
geo_json = json.loads(geo_req.text)
warnings.filterwarnings(&#39;ignore&#39;)
plt.style.use(&#39;seaborn-darkgrid&#39;)


class Datasets:
    &#34;&#34;&#34;
    This class contains some dataset for carrying out calculations
    &#34;&#34;&#34;

    def PER2020_Col_1er_orden(self):
        &#34;&#34;&#34;
        Las PER2020. Tablas generacionales. Se usan para el càlculo de las rentas de supervivencia.
        :return: The PER2020_Col. tabla
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/PER2020_Col_1er.orden.csv&#39;
        data = pd.read_csv(f)
        return data

    def Pasem2020(self):
        &#34;&#34;&#34;
        The PASEM TABLA. Tablas no generacionales. Se usan para el seguro de fallecimiento.
        :return: PASEM2020
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/SpainTables.csv&#39;
        data = pd.read_csv(f)
        return data

    def lifeTables(self):
        &#34;&#34;&#34;

        :return:
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/lifeTable.csv&#39;
        data = pd.read_csv(f, index_col=0)
        return data

    def PER2020_Ind_2ndo_orden(self):
        &#34;&#34;&#34;
        Tablas del 2 orden.
        :return:
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/PER2020_Ind_2ndo.orden.csv&#39;
        data = pd.read_csv(f)
        return data

    def Italians_sim92(self):
        &#34;&#34;&#34;
        SIM92 a numeric vector, 1992 cross section general population males life table
        :return: Old Italian cohort vector
        &#34;&#34;&#34;
        f = &#39;https://github.com/Joevalencia/telma/blob/main/telma/italiani.csv&#39;
        data = pd.read_csv(f).x
        return data


class BiometricModel:
    &#34;&#34;&#34;
    This class permits carrying out multliples basic calculation in life actuarial science.

    From the computation of the basic actuarial table to life expectancy estimation based on a given cohort(s) functions.

    &#34;&#34;&#34;

    def actuarialtable(self, cohort1):
        &#34;&#34;&#34;

        This function computes the basic actuarial table given a cohort (lx):
        the number of people who survive to age x.

        :param cohort1: array-like. It refers to the l{x} vector.

        :return: This method returns a Pandas DataFrame of 8 columns of the cohorts.
                 These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.

        p{x}: The probability that someone aged exactly x will survive to age (x+1). This is l{x+1}/l{x}.

        q{x}: The probability that someone aged exactly x will die before reaching age (x+1).

        d{x}: The number of people who die aged x last birthday. This is d{x} = l{x} - l{x+1} = l{x}*q{x}.

        L{x}: The average number of living in the interval between the exact ages x and x + n.

        T{x}: The total population aged x and older, or the total number of years people lived since age x.

        m{x}: This symbol refers to central rate of mortality.

        e{x}: Life expectancy at the exact age x. That is the average number of years lived by a person since age x.

        &#34;&#34;&#34;

        px1 = (cohort1.shift(-1) / cohort1).fillna(0)
        qx1 = 1 - px1
        dx1 = qx1 * cohort1
        l1 = ((cohort1 + cohort1.shift(1)) / 2).shift(-1)
        tx = []
        for i in range(0, len(l1)):
            tx.append(sum(l1[i:-1]))
        mx = dx1 / l1
        e = []
        for i in range(0, len(cohort1[:-1])):
            lex = cohort1[i]
            e.append(sum(cohort1[i + 1:-1]) / lex)
        exs = pd.Series(e)
        at1 = 0
        if int(cohort1[-1:]) != 0:
            at1 = cohort1.index[-1] + 1
        else:
            at1 = cohort1.index[-1]
        df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1, &#39;dx&#39;: dx1,
                            &#39;qx&#39;: qx1, &#39;px&#39;: px1,
                            &#39;Lx&#39;: l1, &#39;Tx&#39;: tx, &#39;mx&#39;: mx,
                            &#39;ex curtate&#39;: exs})
        print(&#39;--&#39; * 25)
        print(f&#39;Actuarial Table of {cohort1.name}:&#39;)
        print(&#39;--&#39; * 25)
        print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
        print(&#39;Region and Country: &#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
        print(&#39;Omega \u03C9 : &#39;, at1)
        return df1

    def actuarialtable2(self, cohort1, cohorte2):

        &#34;&#34;&#34;
        This method return a Pandas DataFrame of 8 columns for each of the two cohorts.
        These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.

        :return: Actuarial Table for 2 lives
        &#39;Note: Either ex, ey refer to curtate life expectancy
         Note: cohort1 referts to l{x} and cohort2 to l{y}.

        p{y}: The probability that someone aged exactly y will survive to age (y+1). This is l{y+1}/l{y}.

        q{y}: The probability that someone aged exactly y will die before reaching age (y+1).

        d{y}: The number of people who die aged y last birthday. This is d{y} = l{y} - l{y+1} = l{y}*q{y}.

        L{y}: The average number of living in the interval between the exact ages y and y + n.

        T{y}: The total population aged y and older, or the total number of years people lived since age y.

        m{y}: This symbol refers to central rate of mortality.

        e{y}: Life expectancy at the exact age y. That is the average number of years lived by a person since age y.

        Same for x.

        &#34;&#34;&#34;

        ful = []
        if len(cohort1) != len(cohorte2):
            for i in range(abs(len(cohort1) - len(cohorte2))):
                ful.append(0)
            cohort2 = cohorte2.append(pd.Series(ful),
                                      ignore_index=True).astype(str(cohort1.dtype))
        else:
            cohort2 = cohorte2

        px1 = (cohort1.shift(-1) / cohort1).fillna(0)
        px2 = (cohort2.shift(-1) / cohort2).fillna(0)
        qx1, qx2 = 1 - px1, 1 - px2
        dx1, dx2 = qx1 * cohort1, qx2 * cohort2
        l1 = ((cohort1 + cohort1.shift(1)) / 2).shift(-1)
        tx1 = []
        for i in range(0, len(l1)):
            tx1.append(sum(l1[i:-1]))
        mx1 = dx1 / l1
        e1 = []
        for i in range(0, len(cohort1[:-1])):
            lex = cohort1[i]
            e1.append(sum(cohort1[i + 1:-1]) / lex)
        exs = pd.Series(e1).fillna(0)

        l2 = ((cohort2 + cohort2.shift(1)) / 2).shift(-1)
        tx2 = []
        for i in range(0, len(l2)):
            tx2.append(sum(l2[i:-1]))
        mx2 = dx2 / l2
        e2 = []
        for i in range(0, len(cohort2[:-1])):
            ley = cohort2[i]
            e2.append(sum(cohort2[i + 1:-1]) / ley)
        eys = pd.Series(e2).fillna(0)
        at1, at2 = 0, 0
        if int(cohort1[-1:]) != 0 and int(cohorte2[-1:]) != 0:
            at1 = cohort1.index[-1] + 1
            at2 = cohorte2.index[-1] + 1
        elif int(cohort1[-1:]) != 0:
            at1 = cohort1.index[-1] + 1
            at2 = cohorte2.index[-1]
        elif int(cohorte2[-1:]) != 0:
            at1 = cohort1.index[-1]
            at2 = cohorte2.index[-1] + 1
        elif int(cohort1[-1:]) == 0 and int(cohorte2[-1:]) == 0:
            at1 = cohort1.index[-1]
            at2 = cohorte2.index[-1]

        df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1,
                            &#39;l(y)&#39;: cohort2,
                            &#39;dx&#39;: dx1, &#39;dy&#39;: dx2,
                            &#39;qx&#39;: qx1, &#39;qy&#39;: qx2,
                            &#39;px&#39;: px1, &#39;py&#39;: px2,
                            &#39;Lx&#39;: l1, &#39;Ly&#39;: l2,
                            &#39;Tx&#39;: tx1, &#39;Ty&#39;: tx2,
                            &#39;mx&#39;: mx1, &#39;my&#39;: mx2,
                            &#39;ex&#39;: exs, &#39;ey&#39;: eys})
        print(&#39;--&#39; * 35)
        print(f&#39;Actuarial Table of {cohort1.name} and {cohorte2.name}:&#39;)
        print(&#39;--&#39; * 35)
        print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
        print(&#39;Region and Country:&#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
        print(&#39;Omega 1 \u03C9 : &#39;, at1)
        print(&#39;Omega 2 \u03C9 : &#39;, at2)
        return df1

    def omega(self, cohort1, cohort2=None):
        &#34;&#34;&#34;
        Older age of the cohort. This value is known as Actuarial Infinity
        and it is denotes with omega: \u03C9

        :param cohort2: Array-like The cohort function (lx).

        :param cohort1: Array-like The cohort function (lx).

        :return: Last age of the cohort. It is assumed that the index is age-based.
        &#34;&#34;&#34;

        omega1, omega2 = 0, 0
        if int(cohort1[-1:]) != 0:
            omega1 = cohort1.index[-1] + 1
        else:
            omega1 = cohort1.index[-1]
        if cohort2 is not None:
            if int(cohort1[-1:]) != 0:
                omega1 = cohort1.index[-1] + 1
            else:
                omega1 = cohort1.index[-1]
            if int(cohort2[-1:]) != 0:
                omega2 = cohort2.index[-1] + 1
            else:
                omega2 = cohort2.index[-1]
            return omega1, omega2
        return omega1

    def Lx(self, cohort, age: int):
        &#34;&#34;&#34;
        Census survival Function (Lx). It is number of years of life lived between ages x and (x+1) of those currently aged x.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :return: L{x}: The average number of living in the interval between the exact ages x and x + n.
        &#34;&#34;&#34;
        c1 = ((cohort / cohort.shift(1)).shift(-1)).fillna(0)
        dx = (1 - c1) * cohort
        Lx = cohort[age] - dx[age] / 2

        return Lx

    def Tx(self, cohort, age: int):
        &#34;&#34;&#34;
         T{x}: The total population aged x and older, or the total number of years people lived since age x.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :return: Tx at the age x.
        &#34;&#34;&#34;
        l1 = ((cohort + cohort.shift(1)) / 2).shift(-1)
        tx = []
        for i in range(0, len(l1)):
            tx.append(sum(l1[i:-1]))

        return tx[age]

    def central_rate_mortality(self, cohort, age: int):
        &#34;&#34;&#34;
        The central death rate. Is defined as mx=dx/Lx.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :return: The central death rate at age x.
        &#34;&#34;&#34;
        c1 = (cohort.shift(-1) / cohort).fillna(0)
        dx = (1 - c1) * cohort  # Tanto central de mortalidad anual
        Lx = cohort - dx / 2
        mx = dx[age] / Lx[age]
        return round(mx, 7)

    def life_expectancy(self, cohort, age=0, kind: str = &#39;complete&#39;):  # exn
        &#34;&#34;&#34;
        This function computes the life expectancy at ages x.

        :param cohort:  The cohort function (lx).

        :param age:  The age of the individual.

        :param kind:  Type of life expectancy calculated. &#34;Complete&#34; or &#34;curtate&#34; can be computed.

        :return: The life expectancy of the individual aged x.

        &#34;&#34;&#34;

        t = pd.Series(np.arange(1, (120 - age + 1)))
        c1 = (cohort[age + t].sum()) / cohort[age]
        if kind == &#39;complete&#39;:
            return c1.round(2) + .5
        elif kind == &#39;curtate&#39;:
            return c1.round(2)
        else:
            print(&#39;Error. Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)


class OneLife:
    &#34;&#34;&#34;

    This class refers to life actuarial basic calculation on one individual based on a given cohort (lx).

    The life plot permits charting the cohort function in a static or dinamic mode either. (Plotly is required)

    &#34;&#34;&#34;

    def lifeplot(self, cohort1, interactive: bool = False,
                 death: bool = False, qx_log: bool = False):
        &#34;&#34;&#34;
        It plots the graph of the cohort interactively or static either.
        By default is static and plots dx chart.

        :param qx_log: If True it display the log(qx) interactively.

        :param death:  If True it display the deaths interactively.

        :param cohort1: Array-like Cohort function (lx).

        :param interactive: Bool: It displays an interactive chart of
                the survival plot using Plotly.

        :return: Survival Plot of two cohort.
        &#34;&#34;&#34;

        px1 = ((cohort1 / cohort1.shift(1)).shift(-1)).fillna(0)
        qx1 = 1 - px1
        dx1 = qx1 * cohort1

        if not interactive:
            plt.figure(figsize=(15, 5))
            p0 = plt.subplot(1, 2, 1)
            plt.title(f&#39;Survival Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Living people ($l_{x}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 115])
            plt.plot(cohort1.index, cohort1, label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
            plt.legend()
            p1 = plt.subplot(1, 2, 2)
            plt.title(f&#39;Death Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Death people ($d_{x}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 115])
            if qx_log:
                plt.title(f&#39;LogDeath Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
                plt.plot(np.log(qx1), label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
                plt.legend()
                plt.show()
            else:
                plt.plot(dx1, label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
                plt.legend()
                plt.show()

        else:

            import plotly.graph_objects as go
            import plotly.express as px

            if not death:
                px1 = ((cohort1 / cohort1.shift(1)).shift(-1)).fillna(0)
                qx1 = 1 - px1
                dx1 = qx1 * cohort1
                e = []
                for i in range(0, len(cohort1[:-1])):
                    lex = cohort1[i]
                    e.append(sum(cohort1[i + 1:-1]) / lex)
                exs = pd.Series(e)

                df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1, &#39;Life expectancy&#39;: round(exs, 2),
                                    &#39;Age&#39;: cohort1.index})

                fig = px.line(df1, x=&#39;Age&#39;, y=&#39;l(x)&#39;, hover_name=&#39;Life expectancy&#39;,
                              title=f&#39;Survival plot of {cohort1.name}&#39;)
                fig.update_traces(line=dict(color=&#34;crimson&#34;, width=2))
                fig.update_layout(
                    font_family=&#34;COLLEGE&#34;,
                    font_color=&#34;blue&#34;,
                    title_font_family=&#34;New Times Rowan&#34;,
                    title_font_color=&#34;red&#34;,
                    legend_title_font_color=&#34;green&#34;)

                fig.show()

            else:

                plot1 = go.Scatter(x=cohort1.index, y=qx1, mode=&#39;lines&#39;,
                                   name=f&#39;Plot of log q_x - {cohort1.name}&#39;)
                figure = go.Figure([plot1])
                figure.update_layout(title_text=f&#39;Death Plot of {cohort1.name}&#39;,
                                     xaxis_title=&#39;Age&#39;,
                                     yaxis_title=&#39;Death of people $d_{x}$&#39;,
                                     font_family=&#39;COLLEGE&#39;, font_color=&#39;black&#39;,
                                     title_font_color=&#39;red&#39;, title_font_family=&#39;New Times Rowan&#39;,
                                     legend_title_font_color=&#39;green&#39;)

                figure.show()

    def d_x(self, cohort, age: int, t: int = 1):
        &#34;&#34;&#34;
        This function computes the numbers of the between x and x+1.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. The age of the individual.

        :param t: Int. The age from which start differencing.

        :return: The numbers of death within x and x+t.

        &#34;&#34;&#34;

        temporal = t
        sum2 = age + temporal
        dif1 = cohort[age] - cohort[sum2]
        print(f&#39;The number of deaths between {age} and {temporal} are:&#39;)
        return dif1

    def p_x(self, cohort, age: int, t: int = 1,
            i: float = .02, capital: float = 1,
            lump_sum: bool = False):
        &#34;&#34;&#34;
        p_x is the probability that (x) survives to at least age x + t.

        :param i: Float : It is the interest rate.

        :param capital: Float : It is the amount the insurer would paid.

        :param lump_sum: Boolean : If True it computes life insurance lump_sum.

        :param cohort: Array-like : It refers to the living&#39;s vector.

        :param age: Int : It refers to the actual age of the individual.

        :param t: Int : It refers to the time ahead. By default 1.

        :return: The Probability that (x) survives to at least age x + t.

        &#34;&#34;&#34;

        temporal = t
        factor = (1 + i) ** (-temporal)
        s = age + temporal
        probability = np.roll(cohort[s], 1) / cohort[age]
        value = round(factor * probability * capital, 2)
        if not lump_sum:
            print(f&#39;The probability that {age} will survive within {temporal} is:&#39;)
            return probability
        else:
            print(&#39;The life insurance to pay is:&#39;)
            return value, (probability * factor)

    def q_x(self, cohort, age: int, t: int = 1):
        &#34;&#34;&#34;
           q_{x} is the probability that (x) dies before age x + t.

        :param cohort: Array-like : It refers to the living poeple&#39;s vector.

        :param age: Int : It refers to the actual age of the individual.

        :param t: Int : It refers to the period ahead. By default 1.

        :return: The probability that (x) dies before age x + t.

        &#34;&#34;&#34;

        temporal = t
        a = age + temporal
        deaths = np.roll(cohort[age], 1) - cohort[a]
        probability = deaths / cohort[age]
        print(f&#39;The probability that {age} will die within {temporal} is:&#39;)
        return probability

    def deferred_mqx(self, cohort, age: int, m: int = 1,
                     n: int = 1):
        &#34;&#34;&#34;
        - The probability that a person aged exactly x dies between exact ages (x+n) and (x+m+n).

        :param cohort: The cohort function (lx).

        :param age:  The age of the individual.

        :param m:  Int. The deferred period. The period m is sometimes referred to as the deferred period.

        :param n: Period until which the age should be evaluated

        :return:

        &#34;&#34;&#34;

        temporal, survival = n, m
        sum1 = age + temporal
        sum2 = age + temporal + survival
        death = cohort[sum1] - cohort[sum2]
        probability = death / cohort[age]
        print(f&#39;The probability that {age} will survive within {temporal} is:&#39;)
        return probability


class MultipleLives:
    &#34;&#34;&#34;
        This class refers to life actuarial basic calculation on one individual based on a given cohort (lx).

        The life plot permits charting the cohort function in a static or dinamic mode either. (Plotly is required)
        Furthemore is strongly advided inserting in &#34;cohorte2&#34; the cohort function that has a different length from
        &#34;cohort1&#34; and &#34;model&#34;.

        See example in Jupyter examples.

        &#34;&#34;&#34;

    def lifeplot_2(self, cohort1, cohorte2, model=None, interactive: bool = False, qx_log: bool = False,
                   death: bool = False):

        &#34;&#34;&#34;
        It plots the graph of multiple cohorts interactively or static either.

        :param cohort1: The cohort function (lx).

        :param cohorte2: The cohort function (ly).
                         If len(ly)&lt;len(x) please consider passing ly as cohorte.

        :param model: A third cohort function (lz).

        :param qx_log: If True it displays log(qx) cohorts using plotly.

        :param interactive: If True it displays cohorts interactively using plotly.

        :param death: If True it displays dx cohorts using plotly.

        :return: Living Plot, Log(qx) or dx either.

        &#34;&#34;&#34;

        ful = []  ## considerar poner como cohorte2 el vector que tiene diferente longitud en interactively
        if len(cohort1) != len(cohorte2):
            for i in range(abs(len(cohort1) - len(cohorte2))):
                ful.append(0)
            cohort2 = cohorte2.append(pd.Series(ful),
                                      ignore_index=True).astype(str(cohort1.dtype))

        else:
            cohort2 = cohorte2

        #
        px1 = (cohort1.shift(-1) / cohort1).fillna(0)
        px2 = (cohort2.shift(-1) / cohort2).fillna(0)
        qx1, qx2 = 1 - px1, 1 - px2
        dx1, dx2 = qx1 * cohort1, qx2 * cohort2
        qx22 = 1 - (cohorte2.shift(-1) / cohorte2).fillna(0)
        dx22 = qx22 * cohorte2

        e1 = []
        for i in range(0, len(cohort1[:-1])):
            ley = cohort1[i]
            e1.append(sum(cohort1[i + 1:-1]) / ley)
        eyx = pd.Series(e1) + .5

        e2 = []
        for i in range(0, len(cohort2[:-1])):
            ley = cohort2[i]
            e2.append(sum(cohort2[i + 1:-1]) / ley)
        eys = pd.Series(e2) + .5

        df1 = pd.DataFrame({f&#39;{cohort1.name}&#39;: cohort1, &#39;e\u20931&#39;: round(eyx, 2),
                            f&#39;{cohort2.name}&#39;: cohort2, &#39;e\u20932&#39;: round(eys, 2),
                            &#39;Age&#39;: cohort1.index, f&#39;Death {cohort1.name}&#39;: dx1,
                            f&#39;Death {cohort2.name}&#39;: dx2})

        if not interactive:
            plt.figure(figsize=(15, 5))
            p0 = plt.subplot(1, 2, 1)
            plt.title(f&#39;Survival Plot of {cohort1.name} &#39;
                      f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Living people ($l_{x}$) and ($l_{y}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 120])
            plt.plot(cohort1.index, cohort1, label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
            plt.plot(cohorte2.index, cohorte2, label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)
            # plt.legend()
            if model is not None:
                plt.plot(model.index, model, label=f&#39;{model.name}&#39;, color=&#39;red&#39;)
            plt.legend()
            p1 = plt.subplot(1, 2, 2)
            plt.title(f&#39;Death Plot of {cohort1.name} &#39;
                      f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Death people ($d_{x}$) and ($d_{y}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 120])
            if qx_log is True:
                plt.title(f&#39;LogDeath Plot of {cohort1.name} &#39;
                          f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
                plt.ylabel(&#39;LogDeath ($d_{x}$) and ($d_{y}$)&#39;, fontweight=&#39;bold&#39;)
                plt.plot(np.log(qx1), label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
                plt.plot(np.log(qx22), label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)
            else:
                plt.plot(dx1, label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
                plt.plot(dx22, label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)

            if model is not None:
                pxm = ((model / model.shift(1)).shift(-1)).fillna(0)
                qxm = 1 - pxm
                dxm = qxm * model

                if qx_log is True:
                    plt.plot(np.log(qxm.replace(0, 1)), label=f&#39;{model.name}&#39;, color=&#39;red&#39;)
                else:
                    plt.plot(dxm, label=f&#39;{model.name}&#39;, color=&#39;red&#39;)

            plt.legend()

            plt.show()

        else:
            import plotly.express as px
            if not death:
                fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;{cohort1.name}&#39;, f&#39;{cohort2.name}&#39;],
                              hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;],
                              title=f&#39;Survival plot of {cohort1.name} and {cohort2.name}&#39;)
            else:
                if qx_log is True:
                    fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;, f&#39;Death {cohort2.name}&#39;],
                                  hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;], log_y=True,
                                  title=f&#39;LogDeath plot of {cohort1.name} and {cohort2.name}&#39;)
                else:
                    fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;, f&#39;Death {cohort2.name}&#39;],
                                  hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;],
                                  title=f&#39;Death plot of {cohort1.name} and {cohort2.name}&#39;)
            if model is not None:
                pxm = ((model / model.shift(1)).shift(-1)).fillna(0)
                qxm = 1 - pxm
                dxm = qxm * model
                em = []
                for s in range(0, len(model[:-1])):
                    luc = model[s]
                    em.append(sum(model[s + 1:-1]) / luc)
                emm = pd.Series(em) + .5
                df2 = pd.DataFrame({f&#39;{cohort1.name}&#39;: cohort1, f&#39;qx_{cohort1.name}&#39;: round(qx1, 7),
                                    f&#39;{cohort2.name}&#39;: cohort2, f&#39;qx_{cohort2.name}&#39;: round(qx2, 7),
                                    f&#39;{model.name}&#39;: model, f&#39;qx_{model.name}&#39;: round(qxm, 7),
                                    &#39;Age&#39;: cohort1.index, f&#39;Death {cohort1.name}&#39;: round(dx1, 2),
                                    f&#39;Death {cohort2.name}&#39;: round(dx2, 2), f&#39;Death {model.name}&#39;: round(dxm, 2),
                                    &#39;e\u20931&#39;: round(eyx, 2), &#39;e\u20932&#39;: round(eys, 2),
                                    &#39;e\u20933&#39;: round(emm, 2)})
                if death is True:

                    fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;,
                                                   f&#39;Death {cohort2.name}&#39;,
                                                   f&#39;Death {model.name}&#39;],
                                  hover_data=[f&#39;qx_{cohort1.name}&#39;, f&#39;qx_{cohort2.name}&#39;, f&#39;qx_{model.name}&#39;],
                                  title=f&#39;Death plot of {cohort1.name}, {cohort2.name} and {model.name}&#39;)
                    if qx_log is True:
                        fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;qx_{cohort1.name}&#39;,
                                                       f&#39;qx_{cohort2.name}&#39;,
                                                       f&#39;qx_{model.name}&#39;], log_y=True,
                                      hover_data=[f&#39;Death {cohort1.name}&#39;,
                                                  f&#39;Death {cohort2.name}&#39;,
                                                  f&#39;Death {model.name}&#39;],
                                      title=f&#39;Log_qx plot of {cohort1.name}, {cohort2.name} and {model.name}&#39;)

                else:
                    fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;{cohort1.name}&#39;,
                                                   f&#39;{cohort2.name}&#39;,
                                                   f&#39;{model.name}&#39;],
                                  hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;, &#39;e\u20933&#39;],
                                  title=f&#39;Survival plot of {cohort1.name}, {cohorte2.name} and {model.name}&#39;)
            fig.show()

    def p_xy(self, c1, c2, age_x: int, age_y: int, m=0,
             t: int = 1):
        &#34;&#34;&#34;
        The probability that x and y will survive t years.

        :param m: The deferred period.

        :param c1: The cohort function l(x).

        :param c2: cohort function l(y).

        :param age_x: The age of x.

        :param age_y: The age of y.

        :param t: Period until which the age should be evaluated.

        :return: The probability that x and y will survive t years.

        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal + m
        sumy = age_y + temporal + m
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        print(f&#39;The probability that both lives {age_x} and {age_y}&#39;
              f&#39; will be alive after {temporal} years is:&#39;)
        return probability

    def q_xy(self, c1, c2, age_x: int, age_y: int,
             t: int = 1):
        &#34;&#34;&#34;
        It is the probability that at least one of lives (x)
        and (y) will be dead within t years.

        :param c1: cohort function lx.

        :param c2: cohort function ly.

        :param age_x: age of x.


        :param age_y: age of y.

        :param t: Period until which the age should be evaluated.

        :return: The probability that at least one of lives (x)
                    and (y) will be dead within t years.

        &#34;&#34;&#34;
        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = (1 - probabilityx * probabilityy)
        print(f&#39;The probability that at least one of lives {age_x} and {age_y}&#39;
              f&#39; will be dead within {temporal} years is:&#39;)
        return probability

    def no_extinction(self, c1, c2, age_x: int, age_y: int,
                      t: int = 1):
        &#34;&#34;&#34;
        At least one individual will survive within t years

        :param c1: Array-like. Cohort 1.

        :param c2: Array-like. Cohort 2.

        :param age_x: Int. Age of x.

        :param age_y: Int. Age of y.

        :param t: Int. Period until which the age should be evaluate.

        :return: A probability that at least one of x and y will survive.

        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        value = probabilityy + probabilityx - probability
        print(f&#39;The probability that at least one of lives {age_x} &#39;
              f&#39;and {age_y} will be alive after {temporal} years is:&#39;)
        return value

    def dissolution_no_ex(self, c1, c2, age_x: int, age_y: int,
                          t: int = 1):
        &#34;&#34;&#34;
        The probability that exactly one life will survive(remain) within t years.

        :param c1: Array-like. The Cohort function (lx).

        :param c2: Array-like. The Cohort function l(y).

        :param age_x: Int. Age of one individual from cohort 1.

        :param age_y: Int. Age of one individual from cohort 2.

        :param t: Period until which the age should be evaluated.

        :return: The probability that exactly one individual will survive within t years.

        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        value = probabilityy + probabilityx - (2 * probability)
        print(f&#39;The probability that exactly one life will survive withing {t} years is: &#39;)
        return value

    def extinction(self, c1, c2, age_x: int, age_y: int,
                   t: int = 1):
        &#34;&#34;&#34;
        The is the probability that both lives (x) and (y) will be dead within t
        years.

        :param c1: The cohort function lx.

        :param c2: The cohort function ly.

        :param age_x: The age of x.

        :param age_y: The age of y.

        :param t: Period until which the age should  be evaluated.

        :return: The probability that both lives will die within t years.
        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        v = probabilityy + probabilityx - probability
        value = 1 - v
        print(f&#39;The probability that both lives {age_x} and {age_y}&#39;
              f&#39; will be dead within {temporal} years is: &#39;)
        return value


class SpainOperation:

    &#34;&#34;&#34;

    This class is particularly focus on SPANISH life actuarial calculation since annuity are calculated using the BOE.

    Esta clase està principalmente dirigida a las operaciones actuariales del estado espanol, desde el momento en
     que para llevar algunos calculo se usan como referencia las indicaciones del BOE y las PASEM/PERM.

    &#34;&#34;&#34;


    def seguro_fallecimiento(self, tabla_mortalidad):

        &#34;&#34;&#34;

        Esta funciòn permite calcular un seguro de fallecimiento con misma frecuencia de variaciòn
        de cuantìa y pago. Ademas permite calcular un seguro con frecuencia de varianciòn de
        cuantìa y pago diferente. Notar que el computo requiere como parametro la tablas de mortalidad
        PASEM. Los datos para el càlculo se ingresan como input.

        :param tabla_mortalidad: Tabla de mortalidad NO GENERACIONALES PASEM

        :return: VALOR ACTUAL ACTUARIAL DEL SEGURO DE FALLECIMIENTO

        &#34;&#34;&#34;

        frac_freq = int(input(&#39;Frecuencia deseada de fraccionamiento: &#39;))
        x = int(input(&#39;Ingrese la edad del tomador del seguro: &#39;))
        m = int(input(&#39;Ingrese el periodo de diferimiento: &#39;))
        n = int(input(&#39;Temporalidad deseada: &#39;))
        if n == 109:
            n = 109 - (x + m)
        elif n != 109:
            n = n
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        taula = int(input(&#39;Tabla NO GENERACIONAL a escoger:\n&#39;
                          &#39;1: PASEM M 1° ORDEN\n&#39;
                          &#39;2: PASEM F 1° ORDERN\n&#39;
                          &#39;3: PASEM UNISEX 1° ORDEN\n&#39;
                          &#39;4: PASEM M 2° ORDEN\n&#39;
                          &#39;5: PASEM F 2° ORDEN\n&#39;
                          &#39;6: PASEM UNISEX 2° ORDEN\n&#39;))
        L = tabla_mortalidad.iloc[:, taula]
        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(2)  # Tabla creada con fraccionamiento
        interest = float(input(&#39;Tasa de interés: &#39;))  # Base técnica de la operaciòn
        t = np.arange((m * frac_freq), ((m + n) * frac_freq))  # t Periodos del sumatorio
        v = (1 + interest) ** -((t + 1) / frac_freq)
        q1 = jj[x * frac_freq + t] - jj[x * frac_freq + t + 1]
        q2 = jj[x * frac_freq]
        q = q1 / q2  # qx fallecimiento pospagable
        a1 = input(&#39;Seguro Continuo o Discreto: &#39;).lower()
        capital = input(&#39;Ingrese el tipo de Seguro:\n&#39;
                        &#39;&#34;Constante&#34;\n&#39;
                        &#39;&#34;Aritmetica&#34; o &#34;Lineal&#34;\n&#39;
                        &#39;&#34;Geometrica&#34; o &#34;Acumulativa&#34;\n&#39;).lower()
        v1 = interest / np.log(1 + interest)  # Tanto para el seguro continuo
        a2 = input(&#39;Frecuencia de variaciòn de pago y cuantìa diferentes? &#39;).lower()
        if a2 in &#39;no&#39;:
            if capital == &#39;constante&#39;:
                k1 = int(input(&#39;Cuantìa del capital: &#39;))
            elif capital in (&#39;aritmetica&#39;, &#39;lineal&#39;):
                k2 = float(input(&#39;Primer termino: &#39;))
                k2_ = float(input(&#39;Segundo termino: &#39;))
                k1 = k2 + k2_ * (t - m * frac_freq)
            elif capital in (&#39;geometrica&#39;, &#39;acumulativa&#39;):
                k3 = float(input(&#39;Primer termino: &#39;))
                k3_ = float(input(&#39;Tanto acumulativo: &#39;))
                k33 = 1 + k3_
                k1 = k3 * k33 ** (t - m * frac_freq)
            else:
                print(&#39;Error&#39;)
            if a1 in (&#39;continuo&#39;, &#39;no discreto&#39;):
                valor = sum(k1 * q * v) * v1
            elif a1 in (&#39;no continuo&#39;, &#39;discreto&#39;):
                valor = sum(k1 * q * v)
            else:
                print(&#39;Error!&#39;)
        elif a2 in &#39;si&#39;:
            a3 = int(input(&#39;Ingrese la frecuencia de variaciòn de pago (k)\n&#39;
                           &#39;Se refiere al número de términos de igual cuantía dentro de cada período de variación: &#39;))
            if capital == &#39;constante&#39;:
                k1 = int(input(&#39;Cuantìa del capital: &#39;))
            elif capital in (&#39;aritmetica&#39;, &#39;lineal&#39;):
                k2 = float(input(&#39;Primer termino: &#39;))
                k2_ = float(input(&#39;Segundo termino: &#39;))
                k1 = k2 + k2_ * np.floor((t - m * frac_freq) / a3)
            elif capital in (&#39;geometrica&#39;, &#39;acumulativa&#39;):
                k3 = float(input(&#39;Primer termino: &#39;))
                k3_ = float(input(&#39;Tanto acumulativo: &#39;))
                k33 = 1 + k3_
                k1 = k3 * k33 ** np.floor((t - m * frac_freq) / a3)
            else:
                print(&#39;Error&#39;)
            if a1 in (&#39;continuo&#39;, &#39;no discreto&#39;):
                valor = sum(k1 * q * v) * v1
            elif a1 in (&#39;no continuo&#39;, &#39;discreto&#39;):
                valor = sum(k1 * q * v)
            else:
                print(&#39;ERROR! Operaciòn no permitida.&#39;)
        else:
            print(&#39;ERROR! Operaciòn no permitida.&#39;)

        if capital == &#39;constante&#39;:

            print(&#39;=&#39; * 55)
            print(&#39;{0:5} {1:10} {2:10} {3:10}&#39;.format(&#39;t&#39;, &#39;factor v&#39;, &#39;prob. (q)&#39;, &#39;pagamentos actualizados&#39;))
            for bonita in np.arange(0, len(t)):
                print(&#39;{0:2} {1:10} {2:10} {3:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                          np.around(q[bonita], 5),
                                                          np.around(k1 * q[bonita] * v[bonita], 2)))
            print(&#39;=&#39; * 55)
            print(&#39;El Valor del seguro de fallecimento es: &#39;, round(valor, 2))
            print(&#39;=&#39; * 55)
        elif capital != &#39;constante&#39;:

            print(&#39;=&#39; * 55)
            print(&#39;{0:5} {1:10} {2:10} {3:10}&#39;.format(&#39;t&#39;, &#39;factor v&#39;, &#39;prob. (q)&#39;, &#39;pagamentos actualizados&#39;))
            for bonita in np.arange(0, len(t)):
                print(&#39;{0:2} {1:10} {2:10} {3:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                          np.around(q[bonita], 5),
                                                          np.around(k1[bonita] * q[bonita] * v[bonita], 2)))
            print(&#39;=&#39; * 55)
            print(&#39;El Valor del seguro de fallecimento es: &#39;, round(valor, 2))
            print(&#39;=&#39; * 55)  ### Valor del seguro de fallecimiento!

    def renta_constante(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                        h: int = 1, capital: float = 5000, interest: float = .02,
                        birth_year: int = 1975, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;

        Esta funciòn càlcula el valor actual actuarial de una renta de supervivencia constante.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de fraccionamiento.

        :param capital: Dinero - Capital empleado.

        :param interest: Base técnicas.

        :param birth_year: Ano de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia con capital constante.

        &#34;&#34;&#34;
        datatable = tabla_mortalidad
        frac_freq = h
        if n == 120:
            n = 120 - (x + m)
        elif n != 120:
            n = n
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(1)
        if frac_freq != 1:

            if pospagable == &#39;no&#39;:
                t = np.arange((m * h), ((m + n) * h))
                v = (1 + interest) ** -(t / h)
                p = jj[x * h + t] / jj[x * h]
            else:
                t = np.arange((m * h), ((m + n) * h))
                v = (1 + interest) ** -((t + 1) / h)
                p = jj[x * h + t + 1] / jj[x * h]
        else:
            if pospagable == &#39;no&#39;:
                t = np.arange(m, (m + n))
                v = (1 + interest) ** - t
                p = L[x + t] / L[x]
            else:
                t = np.arange(m, (m + n))
                v = (1 + interest) ** - (t + 1)
                p = L[x + t + 1] / L[x]

        renta = round(sum(capital * v * p), 2)

        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             capital,
                                                             np.around(capital * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta  # Valor actual actuarial de la renta constante

    def renta_aritmetica(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                         h: int = 1, capital: float = 500, u1: float = 50, interest: float = .02,
                         birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;

        Esta funciòn permite calcular una renta de supervivencia variable linealmente o aritmeticamente
        con frecuencia de variaciòn de pago y cuantìa igual.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param capital: Primer término de la operaciòn.

        :param u1:  Segundo termino de la operaciòn.

        :param interest:  Base Técnica.

        :param birth_year: Ano de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable linealmente.

        &#34;&#34;&#34;

        datatable = tabla_mortalidad
        frac_freq = h
        if n != 120:
            n = n
        elif n == 120:
            n = 120 - (x + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)

        if frac_freq != 1:

            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            t = np.arange((m * h), ((m + n) * h))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -(t / h)
                p = jj[x * h + t] / jj[x * h]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -((t + 1) / h)
                p = jj[x * h + t + 1] / jj[x * h]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        elif frac_freq == 1:
            t = np.arange(m, ((m + n)))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -t
                p = L[x + t] / L[x]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -(t + 1)
                p = L[x + t + 1] / L[x]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        cap = capital + u1 * (t - m * h)
        renta = round(sum(cap * v * p), 2)

        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def renta_aritmetica2(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                          h: int = 1, h1: int = 1, capital: float = 500, u1: float = 20, interest: float = .02,
                          birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;
        Esta funciòn permite calcular una renta de supervivencia variable linealmente con distinta frecuencia de
        variaciòn de pago y cuantìa.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
                    número de términos de la renta que hay en un año.
        :param capital: Primer término de la operaciòn.

        :param u1:  Segundo termino de la operaciòn.

        :param interest:  Base Técnica

        :param birth_year: Año de nacimiento del individuo

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable linealmente.

        &#34;&#34;&#34;
        datatable = tabla_mortalidad
        k = h1 / h
        frac_freq = h * k
        if n != 120:
            n = n
        elif n == 120:
            n = 120 - (x + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        if frac_freq != 1:
            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            if pospagable == &#39;no&#39;:
                t = np.arange((m * h * k), ((m + n) * h * k), dtype=&#39;int&#39;)
                v = (1 + interest) ** -(t / h1)
                p = jj[x * h1 + t] / jj[x * h1]
            else:
                t = np.arange((m * h * k), ((m + n) * h * k))
                v = (1 + interest) ** -((t + 1) / h * k)
                p = jj[x * h1 + t + 1] / jj[x * h1 * k]

        cap = capital + u1 * np.floor(t / k - m * h)

        renta = round(sum(cap * v * p), 2)
        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def renta_geometrica(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                         h: int = 1, capital: float = 500, q0: float = .015, interest: float = .02,
                         birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;
        Esta funciòn permite calcular una renta de supervivencia variable geometricamente con
        misma frecuencia de variaciò de cuantìa y pago.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param capital:  Primer término de la renta de supervivencia.

        :param q0:  Tanto acumulativo.

        :param interest:  Base técnica.

        :param birth_year: Año de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable geometricamente.

        &#34;&#34;&#34;

        datatable = tabla_mortalidad
        frac_freq = h
        if n == 120:
            n = 120 - (x + m)
        elif n != 120:
            n = n
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        # fr = np.arange(frac_freq) / frac_freq
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        if frac_freq != 1:

            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            t = np.arange((m * h), ((m + n) * h))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -(t / h)
                p = jj[x * h + t] / jj[x * h]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -((t + 1) / h)
                p = jj[x * h + t + 1] / jj[x * h]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        elif frac_freq == 1:
            t = np.arange(m, (m + n))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -t
                p = L[x + t] / L[x]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -(t + 1)
                p = L[x + t + 1] / L[x]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        qux = (1 + q0)
        cap = capital * qux ** (t - m * h)

        renta = round(sum(cap * v * p), 2)
        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def renta_geometrica2(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                          h: int = 1, h1: int = 1, capital: float = 500, q0: float = .015, interest: float = .02,
                          birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;

        Esta funciòn permite calcular una renta de supervivencia variable geometricamente con distinta frecuencia
        de variaciòn de cuantìa y pago.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
                    número de términos de la renta que hay en un año.

        :param capital:  Primer término de la renta de supervivencia.

        :param q0:  Tanto acumulativo.

        :param interest:  Base técnica.

        :param birth_year: Año de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable geometricamente.

        &#34;&#34;&#34;
        datatable = tabla_mortalidad
        k = h1 / h
        frac_freq = h * k
        if n == 120:
            n = n - x
        elif n != 120:
            n = 120 - (x + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        if frac_freq != 1:
            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            if pospagable == &#39;no&#39;:
                t = np.arange((m * h * k), ((m + n) * h * k), dtype=&#39;int&#39;)
                v = (1 + interest) ** -(t / h1)
                p = jj[x * h1 + t] / jj[x * h1]
            else:
                t = np.arange((m * h * k), (n * h * k))
                v = (1 + interest) ** -((t + 1) / h * k)
                p = jj[x * h1 + t + 1] / jj[x * h1 * k]

        qux = (1 + q0)
        cap = capital * qux ** np.floor(t / k - m * h)

        renta = round(sum(cap * v * p), 2)
        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def vida_media_diferida(self, cohorte, x=65, m=10, kind=&#39;completa&#39;):  ## Vida media temporal |abreviada - complete

        &#34;&#34;&#34;
        Es el nùmero medio de años que por término medio vivirà un persona de edad x a partir de la edad x+t.
        Dentro de la pràctica de los seguros la vida media o vida media diferida aparece con frecuencia.
        Por ejemplo, supòngase que una persona contrata a los 30 años una plan de pensiones, a cobrar a partir
        de la jubilaciòn (65). Se desearìa conocer cùal es el nùmero de años que dicha persona vivirà tras la jubilaciòn.

        :param cohorte: La funciòn cohorte (lx). The cohort function (lx)

        :param x: La edad del individuo. The age of the individual x. By Default 65.

        :param m: The deferred period. El periodo de diferimiento. By Default 10.

        :param kind: Kind of mean life expectancy, &#34;complete&#34; or &#34;curtate&#34;. &#34;Completa&#34; o &#34;Abreviada&#34;

        :return: The deferred mean life expectancy.

        &#34;&#34;&#34;
        t = pd.Series(np.arange(m + 1, (120 - x)))
        c1 = (cohorte[x + t].sum()) / cohorte[x]
        if kind == &#39;complete&#39;:
            return c1.round(4) + (.5 * cohorte[x + m] / cohorte[x]).round(4)
        elif kind == &#39;curtate&#39;:
            return c1.round(4)
        else:
            print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)

    def vida_media_temporal(self, cohorte, x=25, n=5, kind=&#39;complete&#39;):  ## pagina 50

        &#34;&#34;&#34;
        Se trata ahora del nùmero de años que port término medio vivirà una persona de edad x en un intervalo de edades
        (x, x+t).

        :param cohorte: Funciòn cohorte (lx).

        :param x: La edad del individuo.

        :param n: La temporalidad a evaluar.

        :param kind: El tipo &#34;completo&#34; o &#34;abreviado&#34;

        :return: El valor de la vida media temporal

        &#34;&#34;&#34;
        if kind == &#39;complete&#39;:
            t = pd.Series(np.arange(1, n))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            c2 = c1 + .5 + .5 * (cohorte[x + n] / cohorte[x])
            return c2.round(7)
        elif kind == &#39;curtate&#39;:
            t = pd.Series(np.arange(1, (n + 1)))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            return c1.round(7)
        else:
            print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)

    def vida_media_mixta(self, cohorte, x=25, m=10, n=5, kind=&#39;complete&#39;):  ## Pagina 51 Estadistica actuarial vida

        &#34;&#34;&#34;
        Se trata ahora del nùmero de años que vivirà una persona de edad x en un intervalo de edades (x+m, x+m+n).

        :param cohorte: La funcin cohorte (lx). The cohort function (lx)

        :param x: La edad del individuo. The age of the individual x

        :param m: The deferred period. El periodo de diferimiento.

        :param n: El periodo hasta la evaluaciòn. The period until which the age should be evaluated

        :param kind: El tipo

        :return: La vida media mixta.

        &#34;&#34;&#34;
        if kind == &#39;complete&#39;:
            t = pd.Series(np.arange((m + 1), (m + n)))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            c2 = .5 * (cohorte[x + m] / cohorte[x]) + .5 * (cohorte[x + m + n] / cohorte[x])
            return (c2 + c1).round(7)
        elif kind == &#39;curtate&#39;:
            t = pd.Series(np.arange((m + 1), (m + n + 1)))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            return c1.round(7)
        else:
            print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)


class InsuranceBenefits:

    &#34;&#34;&#34;

    This class computes basic actuarial operation such as annuity and life insurance.

    It can also computes commutations.

    &#34;&#34;&#34;

    def pure_endowment(self, cohort, age: int, n: int = 1,
                       i: float = .02, capital: float = 1):  # Exn
        &#34;&#34;&#34;
        Function to evaluate the pure endowment.

        Funciòn que evalua el Dotal Puro o Capital diferifo.

        :param capital: Int or Float. The capital.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. It is the age of the insured.

        :param n: Int. Length of the contract.

        :param i: Interest Rate.

        :return: The Actuarial Present Value of the contract and the probability Exn.

        &#34;&#34;&#34;

        time = n
        factor = 1 / (1 + i) ** time
        s = age + time
        probability = np.roll(cohort[s], 1) / cohort[age]
        n_ex = round(factor * probability, 7)
        endow = n_ex * capital
        print(f&#39;The Pure Endowment and value for an individual aged {age} \n&#39;
              f&#39;with a length contract of {time} given {capital} bucks is:\n&#39;)
        return round(endow, 2), n_ex  # Value of Pure Endowment without calculation

    def increasing_annuity(self, cohort, x, m=0, i=.02,
                           payments: str = &#39;advance&#39;):

        &#34;&#34;&#34;

        This function evaluates increasing annuities.

        :param cohort: The cohort function (lx).

        :param x: The age of insured

        :param m: The deferred period.

        :param i: Interest Rate.

        :param payments: The kind of increasing annuity. &#34;advance&#34; or &#34;arrears&#34; are accepted.

        :return:  The increasing annuity (advance or arrears).

        &#34;&#34;&#34;
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        # Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))

        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        if payments == &#39;advance&#39;:
            iaxn = (Sx[x + m]) / Dx[x]
        elif payments == &#39;arrears&#39;:
            iaxn = (Sx[x + m + 1]) / Dx[x]
        return iaxn

    def increasing_lifeinsurance(self, cohort, age, n=0, m=0, i=.02, kind=&#39;whole&#39;):

        &#34;&#34;&#34;

        :param cohort: The cohort function (lx).

        :param age: The age of insured

        :param n: The time of evaluation.

        :param m: The deferred period.

        :param i: Interest Rate.

        :param kind: The kind of increasing life insurance. &#34;Whole&#34; or &#34;Temporary&#34; are accepted.

        :return: The increasing life insurance.

        &#34;&#34;&#34;
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))
        if kind == &#39;whole&#39;:
            ias = Rx[age + m] / Dx[age]
            return round(ias, 6)
        elif kind == &#39;temporary&#39;:
            ias = (Rx[age + m] - Rx[age + n + m] - n * Mx[age + n + m]) / Dx[age]
            return round(ias, 6)
        else:
            print(&#39;Error! &#34;Kind&#34; can be &#34;whole&#34; or &#34;temporary&#34; either&#39;)

    def decreasing_annuity(self, cohort, age, m=0, n=1, i=.02, payments=&#39;advance&#39;):

        &#34;&#34;&#34;

        :param cohort: The cohort function (lx).

        :param age: The age of insured

        :param n: The time of evaluation.

        :param m: The deferred period.

        :param i: Interest Rate.

        :param payments: The kind of payments. It can be &#34;advance&#34; or &#34;arrears&#34;.

        :return: The decreasing annuity.

        &#34;&#34;&#34;

        x = age
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))

        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))

        if payments == &#39;advance&#39;:
            daxn = ((n * Nx[x]) - (Sx[x + m + 1] - Sx[x + m + n + 1])) / Dx[x]
        elif payments == &#39;arrears&#39;:
            daxn = ((n * Nx[x + 1]) - (Sx[x + m + 2] - Sx[x + m + n + 2])) / Dx[x]
        else:
            print(&#39;Error! Insert right &#34;advance&#34; or &#34;arrears&#34; &#39;)
        return daxn

    def temporary_annuity(self, cohort, age: int, n: int = &#39;whole&#39;, m=1,
                          i: float = .02, capital: float = 1, payments: str = &#39;advance&#39;):  # axn

        &#34;&#34;&#34;

        Temporary annuity function.
        Annuity advance and arrears can be evaluated.
        This function calculates actuarial value of annuities, given a cohort.
        Por defecto càlcula la annuity-advance, puede pasarsele la arrears.

        :param capital: Int or Float. The capital.

        :param payments: The kind of annuity &#34;arrears&#34; or &#34;advance&#34;.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. It is the age of the insured.

        :param n: Int. Length of the contract. If missing is assumed until omega.

        :param m: Number of fractional payments per period. By default 1.

        :param i: Interest Rate.

        :return: Temporary annuity.

        &#34;&#34;&#34;

        def omegas():
            omega1 = 0

            if int(cohort[-1:]) != 0:
                omega1 = cohort.index[-1] + 1
            else:
                omega1 = cohort.index[-1]
            return omega1

        # omegas()
        if n != &#39;whole&#39;:
            n = n
        elif n == &#39;whole&#39;:
            n = omegas() - (age + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)

        ## Imprentando tomar la temporalidad
        time = n
        Dx = (1 + i) ** (-cohort.index) * cohort
        w = len(Dx)
        nex = Dx[age + n] / Dx[age]  ## Dotal Puro
        konstante = (m - 1) / (2 * m)
        Nx = []
        for valor in range(0, w):
            Nx.append(sum(Dx[valor:]))

        if payments == &#39;arrears&#39;:
            print(&#39;The actuarial value of this annuity-arrears is:&#39;)
            axn = (Nx[age + 1] - Nx[age + time + 1]) / Dx[age]
            axn1 = axn + konstante * (1 - nex)  ## Using Approximation
            return round(axn1 * capital, 5)
        elif payments == &#39;advance&#39;:
            print(&#39;The actuarial value of this annuity-advance is:&#39;)
            axn2 = (Nx[age] - Nx[age + time]) / Dx[age]
            axn3 = axn2 - konstante * (1 - nex)  ## Using Approximation
            return round(axn3 * capital, 5)
        else:
            print(&#39;Payments parameter should be advance (default) or arrears either&#39;)

    def deferred_annuity(self, cohort, age: int, n: int = 10,
                         m: int = 5, i: float = .02, capital: float = 1,
                         payments=&#39;advance&#39;):
        &#34;&#34;&#34;

        :param capital: Float. The capital.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. It is the age of the insured.

        :param n: Int. Length of the contract.

        :param m: Int. The deferred period.

        :param i: Interest Rate.

        :param payments:  The kind

        :return:

        &#34;&#34;&#34;

        time = n
        Dx = (1 + i) ** (-cohort.index) * cohort
        n = len(Dx)
        Nx = []
        for valor in range(0, n):
            Nx.append(sum(Dx[valor:]))
        if payments == &#39;arrears&#39;:
            axn = (Nx[age + m + 1] - Nx[age + m + time + 1]) / Dx[age]
            return round(axn * capital, 5)
        elif payments == &#39;advance&#39;:
            axn2 = (Nx[age + m] - Nx[age + m + time]) / Dx[age]
            return round(axn2 * capital, 5)
        elif payments == &#39;whole arrears&#39;:
            axn3 = Nx[age + m + 1] / Dx[age]
            return round(axn3 * capital, 5)
        elif payments == &#39;whole advance&#39;:
            axn3 = Nx[age + m] / Dx[age]
            return round(axn3 * capital, 5)
        else:
            print(&#39;Please the payments should be specified as &#34;advance&#34;, &#34;arrears&#34;, &#34;whole advance&#34; or &#39;
                  &#39;&#34;whole arrears&#34; either&#39;)

    def commutations(self, cohort, i: float = .02):
        &#34;&#34;&#34;

        Tabulates the actuarial commutation functions.

        Calcula las communtaciones dada una coorte y tasa i.

        :param cohort: The cohort function (lx).

        :param i: Float. Interest Rate.

        :return: The table of commutations given i (rate).

        &#34;&#34;&#34;

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))

        df = pd.DataFrame({&#39;lx&#39;: cohort, &#39;Dx&#39;: Dx, &#39;Nx&#39;: Nx,
                           &#39;Cx&#39;: Cx, &#39;Mx&#39;: Mx, &#39;Rx&#39;: Rx, &#39;Sx&#39;: Sx})
        print(&#39;--&#39; * 25)
        print(f&#39;Commutations results of {cohort.name}:&#39;)
        print(&#39;--&#39; * 25)
        print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
        print(&#39;Region and Country: &#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
        return df  ## Commutations

    def endowment(self, cohort, age: int, t: int = 1, i: float = .02,
                  capital: float = 1):  # AExn
        &#34;&#34;&#34;

        Function to evaluate the n-year endowment insurance.

        :param cohort: The cohort function (lx).

        :param age: Int. Age of the insured.

        :param t: The length of the contract.

        :param i: Interest Rate.

        :param capital: Float. The capital of the operation.

        :return:  The endowment.

        &#34;&#34;&#34;
        time = t
        fee = capital
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        pagamento = (Mx[age] - Mx[age + time] + Dx[age + time]) / Dx[age]
        tariffa = round(pagamento * fee, 2)
        print(f&#39;The endowment of age {age}: is {tariffa} and his probability is {pagamento}&#39;)
        return tariffa

    def tincreasing_annuity(self, cohort, x, m=0, n=1, i=.02,
                            payments: str = &#39;advance&#39;):  ## m deferred period.

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))

        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))

        if payments == &#39;advance&#39;:
            iaxn = (Sx[x + m] - Sx[x + n + m] - n * Nx[x + n + m]) / Dx[x]
        elif payments == &#39;arrears&#39;:
            iaxn = (Sx[x + m] - Sx[x + m + n + 1] - n * Nx[x + n + m + 1]) / Dx[x]
        return iaxn

    def whole_life_insurance(self, cohort, age, i: float = .02,
                             capital: float = 1, kind: str = &#39;whole&#39;):
        &#34;&#34;&#34;

         A payment of 1 is made at the end of the year of death of a person
            aged x.

        :param cohort: The cohort function (lx).

        :param age: The Age of the individual.

        :param i: Interest Rate.

        :param capital: The capital of the operation.

        :param kind: The kind of life insurance contract. &#34;Whole&#34; or &#34;Immediate&#34;.

        :return:  The present value of the payment of the whole life insurance.

        &#34;&#34;&#34;

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))

        if kind == &#39;immediate&#39;:
            v = (1 + i) ** .5
            insurance = v * Mx[age] / Dx[age]
        elif kind == &#39;whole&#39;:
            insurance = Mx[age] / Dx[age]
        else:
            print(&#39;Only &#34;whole&#34; and &#34;immediate&#34; are accepted!&#39;)

        return round(insurance * capital, 7)

    def temporary_insurance(self, cohort, age, m: int = 0, n: int = 1, i: float = .02,
                            capital: float = 1):
        &#34;&#34;&#34;

        A payment of 1 is made at the end of the year of death of a
        person aged x provided the person dies within n years.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :param m: The deferred period.

        :param n: Period until which the age should be evaluated.

        :param i: Interest Rate.

        :param capital: The capital.

        :return: The present value of the payments.

        &#34;&#34;&#34;

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))

        insurance = (Mx[age + m] - Mx[age + m + n]) / Dx[age]

        return round(insurance * capital, 5)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="telma.BiometricModel"><code class="flex name class">
<span>class <span class="ident">BiometricModel</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class permits carrying out multliples basic calculation in life actuarial science.</p>
<p>From the computation of the basic actuarial table to life expectancy estimation based on a given cohort(s) functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BiometricModel:
    &#34;&#34;&#34;
    This class permits carrying out multliples basic calculation in life actuarial science.

    From the computation of the basic actuarial table to life expectancy estimation based on a given cohort(s) functions.

    &#34;&#34;&#34;

    def actuarialtable(self, cohort1):
        &#34;&#34;&#34;

        This function computes the basic actuarial table given a cohort (lx):
        the number of people who survive to age x.

        :param cohort1: array-like. It refers to the l{x} vector.

        :return: This method returns a Pandas DataFrame of 8 columns of the cohorts.
                 These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.

        p{x}: The probability that someone aged exactly x will survive to age (x+1). This is l{x+1}/l{x}.

        q{x}: The probability that someone aged exactly x will die before reaching age (x+1).

        d{x}: The number of people who die aged x last birthday. This is d{x} = l{x} - l{x+1} = l{x}*q{x}.

        L{x}: The average number of living in the interval between the exact ages x and x + n.

        T{x}: The total population aged x and older, or the total number of years people lived since age x.

        m{x}: This symbol refers to central rate of mortality.

        e{x}: Life expectancy at the exact age x. That is the average number of years lived by a person since age x.

        &#34;&#34;&#34;

        px1 = (cohort1.shift(-1) / cohort1).fillna(0)
        qx1 = 1 - px1
        dx1 = qx1 * cohort1
        l1 = ((cohort1 + cohort1.shift(1)) / 2).shift(-1)
        tx = []
        for i in range(0, len(l1)):
            tx.append(sum(l1[i:-1]))
        mx = dx1 / l1
        e = []
        for i in range(0, len(cohort1[:-1])):
            lex = cohort1[i]
            e.append(sum(cohort1[i + 1:-1]) / lex)
        exs = pd.Series(e)
        at1 = 0
        if int(cohort1[-1:]) != 0:
            at1 = cohort1.index[-1] + 1
        else:
            at1 = cohort1.index[-1]
        df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1, &#39;dx&#39;: dx1,
                            &#39;qx&#39;: qx1, &#39;px&#39;: px1,
                            &#39;Lx&#39;: l1, &#39;Tx&#39;: tx, &#39;mx&#39;: mx,
                            &#39;ex curtate&#39;: exs})
        print(&#39;--&#39; * 25)
        print(f&#39;Actuarial Table of {cohort1.name}:&#39;)
        print(&#39;--&#39; * 25)
        print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
        print(&#39;Region and Country: &#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
        print(&#39;Omega \u03C9 : &#39;, at1)
        return df1

    def actuarialtable2(self, cohort1, cohorte2):

        &#34;&#34;&#34;
        This method return a Pandas DataFrame of 8 columns for each of the two cohorts.
        These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.

        :return: Actuarial Table for 2 lives
        &#39;Note: Either ex, ey refer to curtate life expectancy
         Note: cohort1 referts to l{x} and cohort2 to l{y}.

        p{y}: The probability that someone aged exactly y will survive to age (y+1). This is l{y+1}/l{y}.

        q{y}: The probability that someone aged exactly y will die before reaching age (y+1).

        d{y}: The number of people who die aged y last birthday. This is d{y} = l{y} - l{y+1} = l{y}*q{y}.

        L{y}: The average number of living in the interval between the exact ages y and y + n.

        T{y}: The total population aged y and older, or the total number of years people lived since age y.

        m{y}: This symbol refers to central rate of mortality.

        e{y}: Life expectancy at the exact age y. That is the average number of years lived by a person since age y.

        Same for x.

        &#34;&#34;&#34;

        ful = []
        if len(cohort1) != len(cohorte2):
            for i in range(abs(len(cohort1) - len(cohorte2))):
                ful.append(0)
            cohort2 = cohorte2.append(pd.Series(ful),
                                      ignore_index=True).astype(str(cohort1.dtype))
        else:
            cohort2 = cohorte2

        px1 = (cohort1.shift(-1) / cohort1).fillna(0)
        px2 = (cohort2.shift(-1) / cohort2).fillna(0)
        qx1, qx2 = 1 - px1, 1 - px2
        dx1, dx2 = qx1 * cohort1, qx2 * cohort2
        l1 = ((cohort1 + cohort1.shift(1)) / 2).shift(-1)
        tx1 = []
        for i in range(0, len(l1)):
            tx1.append(sum(l1[i:-1]))
        mx1 = dx1 / l1
        e1 = []
        for i in range(0, len(cohort1[:-1])):
            lex = cohort1[i]
            e1.append(sum(cohort1[i + 1:-1]) / lex)
        exs = pd.Series(e1).fillna(0)

        l2 = ((cohort2 + cohort2.shift(1)) / 2).shift(-1)
        tx2 = []
        for i in range(0, len(l2)):
            tx2.append(sum(l2[i:-1]))
        mx2 = dx2 / l2
        e2 = []
        for i in range(0, len(cohort2[:-1])):
            ley = cohort2[i]
            e2.append(sum(cohort2[i + 1:-1]) / ley)
        eys = pd.Series(e2).fillna(0)
        at1, at2 = 0, 0
        if int(cohort1[-1:]) != 0 and int(cohorte2[-1:]) != 0:
            at1 = cohort1.index[-1] + 1
            at2 = cohorte2.index[-1] + 1
        elif int(cohort1[-1:]) != 0:
            at1 = cohort1.index[-1] + 1
            at2 = cohorte2.index[-1]
        elif int(cohorte2[-1:]) != 0:
            at1 = cohort1.index[-1]
            at2 = cohorte2.index[-1] + 1
        elif int(cohort1[-1:]) == 0 and int(cohorte2[-1:]) == 0:
            at1 = cohort1.index[-1]
            at2 = cohorte2.index[-1]

        df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1,
                            &#39;l(y)&#39;: cohort2,
                            &#39;dx&#39;: dx1, &#39;dy&#39;: dx2,
                            &#39;qx&#39;: qx1, &#39;qy&#39;: qx2,
                            &#39;px&#39;: px1, &#39;py&#39;: px2,
                            &#39;Lx&#39;: l1, &#39;Ly&#39;: l2,
                            &#39;Tx&#39;: tx1, &#39;Ty&#39;: tx2,
                            &#39;mx&#39;: mx1, &#39;my&#39;: mx2,
                            &#39;ex&#39;: exs, &#39;ey&#39;: eys})
        print(&#39;--&#39; * 35)
        print(f&#39;Actuarial Table of {cohort1.name} and {cohorte2.name}:&#39;)
        print(&#39;--&#39; * 35)
        print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
        print(&#39;Region and Country:&#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
        print(&#39;Omega 1 \u03C9 : &#39;, at1)
        print(&#39;Omega 2 \u03C9 : &#39;, at2)
        return df1

    def omega(self, cohort1, cohort2=None):
        &#34;&#34;&#34;
        Older age of the cohort. This value is known as Actuarial Infinity
        and it is denotes with omega: \u03C9

        :param cohort2: Array-like The cohort function (lx).

        :param cohort1: Array-like The cohort function (lx).

        :return: Last age of the cohort. It is assumed that the index is age-based.
        &#34;&#34;&#34;

        omega1, omega2 = 0, 0
        if int(cohort1[-1:]) != 0:
            omega1 = cohort1.index[-1] + 1
        else:
            omega1 = cohort1.index[-1]
        if cohort2 is not None:
            if int(cohort1[-1:]) != 0:
                omega1 = cohort1.index[-1] + 1
            else:
                omega1 = cohort1.index[-1]
            if int(cohort2[-1:]) != 0:
                omega2 = cohort2.index[-1] + 1
            else:
                omega2 = cohort2.index[-1]
            return omega1, omega2
        return omega1

    def Lx(self, cohort, age: int):
        &#34;&#34;&#34;
        Census survival Function (Lx). It is number of years of life lived between ages x and (x+1) of those currently aged x.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :return: L{x}: The average number of living in the interval between the exact ages x and x + n.
        &#34;&#34;&#34;
        c1 = ((cohort / cohort.shift(1)).shift(-1)).fillna(0)
        dx = (1 - c1) * cohort
        Lx = cohort[age] - dx[age] / 2

        return Lx

    def Tx(self, cohort, age: int):
        &#34;&#34;&#34;
         T{x}: The total population aged x and older, or the total number of years people lived since age x.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :return: Tx at the age x.
        &#34;&#34;&#34;
        l1 = ((cohort + cohort.shift(1)) / 2).shift(-1)
        tx = []
        for i in range(0, len(l1)):
            tx.append(sum(l1[i:-1]))

        return tx[age]

    def central_rate_mortality(self, cohort, age: int):
        &#34;&#34;&#34;
        The central death rate. Is defined as mx=dx/Lx.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :return: The central death rate at age x.
        &#34;&#34;&#34;
        c1 = (cohort.shift(-1) / cohort).fillna(0)
        dx = (1 - c1) * cohort  # Tanto central de mortalidad anual
        Lx = cohort - dx / 2
        mx = dx[age] / Lx[age]
        return round(mx, 7)

    def life_expectancy(self, cohort, age=0, kind: str = &#39;complete&#39;):  # exn
        &#34;&#34;&#34;
        This function computes the life expectancy at ages x.

        :param cohort:  The cohort function (lx).

        :param age:  The age of the individual.

        :param kind:  Type of life expectancy calculated. &#34;Complete&#34; or &#34;curtate&#34; can be computed.

        :return: The life expectancy of the individual aged x.

        &#34;&#34;&#34;

        t = pd.Series(np.arange(1, (120 - age + 1)))
        c1 = (cohort[age + t].sum()) / cohort[age]
        if kind == &#39;complete&#39;:
            return c1.round(2) + .5
        elif kind == &#39;curtate&#39;:
            return c1.round(2)
        else:
            print(&#39;Error. Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="telma.BiometricModel.Lx"><code class="name flex">
<span>def <span class="ident">Lx</span></span>(<span>self, cohort, age: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Census survival Function (Lx). It is number of years of life lived between ages x and (x+1) of those currently aged x.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param age: The age of the individual.</p>
<p>:return: L{x}: The average number of living in the interval between the exact ages x and x + n.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Lx(self, cohort, age: int):
    &#34;&#34;&#34;
    Census survival Function (Lx). It is number of years of life lived between ages x and (x+1) of those currently aged x.

    :param cohort: The cohort function (lx).

    :param age: The age of the individual.

    :return: L{x}: The average number of living in the interval between the exact ages x and x + n.
    &#34;&#34;&#34;
    c1 = ((cohort / cohort.shift(1)).shift(-1)).fillna(0)
    dx = (1 - c1) * cohort
    Lx = cohort[age] - dx[age] / 2

    return Lx</code></pre>
</details>
</dd>
<dt id="telma.BiometricModel.Tx"><code class="name flex">
<span>def <span class="ident">Tx</span></span>(<span>self, cohort, age: int)</span>
</code></dt>
<dd>
<div class="desc"><p>T{x}: The total population aged x and older, or the total number of years people lived since age x.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param age: The age of the individual.</p>
<p>:return: Tx at the age x.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Tx(self, cohort, age: int):
    &#34;&#34;&#34;
     T{x}: The total population aged x and older, or the total number of years people lived since age x.

    :param cohort: The cohort function (lx).

    :param age: The age of the individual.

    :return: Tx at the age x.
    &#34;&#34;&#34;
    l1 = ((cohort + cohort.shift(1)) / 2).shift(-1)
    tx = []
    for i in range(0, len(l1)):
        tx.append(sum(l1[i:-1]))

    return tx[age]</code></pre>
</details>
</dd>
<dt id="telma.BiometricModel.actuarialtable"><code class="name flex">
<span>def <span class="ident">actuarialtable</span></span>(<span>self, cohort1)</span>
</code></dt>
<dd>
<div class="desc"><p>This function computes the basic actuarial table given a cohort (lx):
the number of people who survive to age x.</p>
<p>:param cohort1: array-like. It refers to the l{x} vector.</p>
<p>:return: This method returns a Pandas DataFrame of 8 columns of the cohorts.
These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.</p>
<p>p{x}: The probability that someone aged exactly x will survive to age (x+1). This is l{x+1}/l{x}.</p>
<p>q{x}: The probability that someone aged exactly x will die before reaching age (x+1).</p>
<p>d{x}: The number of people who die aged x last birthday. This is d{x} = l{x} - l{x+1} = l{x}*q{x}.</p>
<p>L{x}: The average number of living in the interval between the exact ages x and x + n.</p>
<p>T{x}: The total population aged x and older, or the total number of years people lived since age x.</p>
<p>m{x}: This symbol refers to central rate of mortality.</p>
<p>e{x}: Life expectancy at the exact age x. That is the average number of years lived by a person since age x.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def actuarialtable(self, cohort1):
    &#34;&#34;&#34;

    This function computes the basic actuarial table given a cohort (lx):
    the number of people who survive to age x.

    :param cohort1: array-like. It refers to the l{x} vector.

    :return: This method returns a Pandas DataFrame of 8 columns of the cohorts.
             These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.

    p{x}: The probability that someone aged exactly x will survive to age (x+1). This is l{x+1}/l{x}.

    q{x}: The probability that someone aged exactly x will die before reaching age (x+1).

    d{x}: The number of people who die aged x last birthday. This is d{x} = l{x} - l{x+1} = l{x}*q{x}.

    L{x}: The average number of living in the interval between the exact ages x and x + n.

    T{x}: The total population aged x and older, or the total number of years people lived since age x.

    m{x}: This symbol refers to central rate of mortality.

    e{x}: Life expectancy at the exact age x. That is the average number of years lived by a person since age x.

    &#34;&#34;&#34;

    px1 = (cohort1.shift(-1) / cohort1).fillna(0)
    qx1 = 1 - px1
    dx1 = qx1 * cohort1
    l1 = ((cohort1 + cohort1.shift(1)) / 2).shift(-1)
    tx = []
    for i in range(0, len(l1)):
        tx.append(sum(l1[i:-1]))
    mx = dx1 / l1
    e = []
    for i in range(0, len(cohort1[:-1])):
        lex = cohort1[i]
        e.append(sum(cohort1[i + 1:-1]) / lex)
    exs = pd.Series(e)
    at1 = 0
    if int(cohort1[-1:]) != 0:
        at1 = cohort1.index[-1] + 1
    else:
        at1 = cohort1.index[-1]
    df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1, &#39;dx&#39;: dx1,
                        &#39;qx&#39;: qx1, &#39;px&#39;: px1,
                        &#39;Lx&#39;: l1, &#39;Tx&#39;: tx, &#39;mx&#39;: mx,
                        &#39;ex curtate&#39;: exs})
    print(&#39;--&#39; * 25)
    print(f&#39;Actuarial Table of {cohort1.name}:&#39;)
    print(&#39;--&#39; * 25)
    print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
    print(&#39;Region and Country: &#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
    print(&#39;Omega \u03C9 : &#39;, at1)
    return df1</code></pre>
</details>
</dd>
<dt id="telma.BiometricModel.actuarialtable2"><code class="name flex">
<span>def <span class="ident">actuarialtable2</span></span>(<span>self, cohort1, cohorte2)</span>
</code></dt>
<dd>
<div class="desc"><p>This method return a Pandas DataFrame of 8 columns for each of the two cohorts.
These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.</p>
<p>:return: Actuarial Table for 2 lives
'Note: Either ex, ey refer to curtate life expectancy
Note: cohort1 referts to l{x} and cohort2 to l{y}.</p>
<p>p{y}: The probability that someone aged exactly y will survive to age (y+1). This is l{y+1}/l{y}.</p>
<p>q{y}: The probability that someone aged exactly y will die before reaching age (y+1).</p>
<p>d{y}: The number of people who die aged y last birthday. This is d{y} = l{y} - l{y+1} = l{y}*q{y}.</p>
<p>L{y}: The average number of living in the interval between the exact ages y and y + n.</p>
<p>T{y}: The total population aged y and older, or the total number of years people lived since age y.</p>
<p>m{y}: This symbol refers to central rate of mortality.</p>
<p>e{y}: Life expectancy at the exact age y. That is the average number of years lived by a person since age y.</p>
<p>Same for x.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def actuarialtable2(self, cohort1, cohorte2):

    &#34;&#34;&#34;
    This method return a Pandas DataFrame of 8 columns for each of the two cohorts.
    These columns are composed by Livings, Deaths, q_{x}, p_{x}, L{x}, m{x}, T{x}, e{x}.

    :return: Actuarial Table for 2 lives
    &#39;Note: Either ex, ey refer to curtate life expectancy
     Note: cohort1 referts to l{x} and cohort2 to l{y}.

    p{y}: The probability that someone aged exactly y will survive to age (y+1). This is l{y+1}/l{y}.

    q{y}: The probability that someone aged exactly y will die before reaching age (y+1).

    d{y}: The number of people who die aged y last birthday. This is d{y} = l{y} - l{y+1} = l{y}*q{y}.

    L{y}: The average number of living in the interval between the exact ages y and y + n.

    T{y}: The total population aged y and older, or the total number of years people lived since age y.

    m{y}: This symbol refers to central rate of mortality.

    e{y}: Life expectancy at the exact age y. That is the average number of years lived by a person since age y.

    Same for x.

    &#34;&#34;&#34;

    ful = []
    if len(cohort1) != len(cohorte2):
        for i in range(abs(len(cohort1) - len(cohorte2))):
            ful.append(0)
        cohort2 = cohorte2.append(pd.Series(ful),
                                  ignore_index=True).astype(str(cohort1.dtype))
    else:
        cohort2 = cohorte2

    px1 = (cohort1.shift(-1) / cohort1).fillna(0)
    px2 = (cohort2.shift(-1) / cohort2).fillna(0)
    qx1, qx2 = 1 - px1, 1 - px2
    dx1, dx2 = qx1 * cohort1, qx2 * cohort2
    l1 = ((cohort1 + cohort1.shift(1)) / 2).shift(-1)
    tx1 = []
    for i in range(0, len(l1)):
        tx1.append(sum(l1[i:-1]))
    mx1 = dx1 / l1
    e1 = []
    for i in range(0, len(cohort1[:-1])):
        lex = cohort1[i]
        e1.append(sum(cohort1[i + 1:-1]) / lex)
    exs = pd.Series(e1).fillna(0)

    l2 = ((cohort2 + cohort2.shift(1)) / 2).shift(-1)
    tx2 = []
    for i in range(0, len(l2)):
        tx2.append(sum(l2[i:-1]))
    mx2 = dx2 / l2
    e2 = []
    for i in range(0, len(cohort2[:-1])):
        ley = cohort2[i]
        e2.append(sum(cohort2[i + 1:-1]) / ley)
    eys = pd.Series(e2).fillna(0)
    at1, at2 = 0, 0
    if int(cohort1[-1:]) != 0 and int(cohorte2[-1:]) != 0:
        at1 = cohort1.index[-1] + 1
        at2 = cohorte2.index[-1] + 1
    elif int(cohort1[-1:]) != 0:
        at1 = cohort1.index[-1] + 1
        at2 = cohorte2.index[-1]
    elif int(cohorte2[-1:]) != 0:
        at1 = cohort1.index[-1]
        at2 = cohorte2.index[-1] + 1
    elif int(cohort1[-1:]) == 0 and int(cohorte2[-1:]) == 0:
        at1 = cohort1.index[-1]
        at2 = cohorte2.index[-1]

    df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1,
                        &#39;l(y)&#39;: cohort2,
                        &#39;dx&#39;: dx1, &#39;dy&#39;: dx2,
                        &#39;qx&#39;: qx1, &#39;qy&#39;: qx2,
                        &#39;px&#39;: px1, &#39;py&#39;: px2,
                        &#39;Lx&#39;: l1, &#39;Ly&#39;: l2,
                        &#39;Tx&#39;: tx1, &#39;Ty&#39;: tx2,
                        &#39;mx&#39;: mx1, &#39;my&#39;: mx2,
                        &#39;ex&#39;: exs, &#39;ey&#39;: eys})
    print(&#39;--&#39; * 35)
    print(f&#39;Actuarial Table of {cohort1.name} and {cohorte2.name}:&#39;)
    print(&#39;--&#39; * 35)
    print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
    print(&#39;Region and Country:&#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
    print(&#39;Omega 1 \u03C9 : &#39;, at1)
    print(&#39;Omega 2 \u03C9 : &#39;, at2)
    return df1</code></pre>
</details>
</dd>
<dt id="telma.BiometricModel.central_rate_mortality"><code class="name flex">
<span>def <span class="ident">central_rate_mortality</span></span>(<span>self, cohort, age: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The central death rate. Is defined as mx=dx/Lx.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param age: The age of the individual.</p>
<p>:return: The central death rate at age x.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def central_rate_mortality(self, cohort, age: int):
    &#34;&#34;&#34;
    The central death rate. Is defined as mx=dx/Lx.

    :param cohort: The cohort function (lx).

    :param age: The age of the individual.

    :return: The central death rate at age x.
    &#34;&#34;&#34;
    c1 = (cohort.shift(-1) / cohort).fillna(0)
    dx = (1 - c1) * cohort  # Tanto central de mortalidad anual
    Lx = cohort - dx / 2
    mx = dx[age] / Lx[age]
    return round(mx, 7)</code></pre>
</details>
</dd>
<dt id="telma.BiometricModel.life_expectancy"><code class="name flex">
<span>def <span class="ident">life_expectancy</span></span>(<span>self, cohort, age=0, kind: str = 'complete')</span>
</code></dt>
<dd>
<div class="desc"><p>This function computes the life expectancy at ages x.</p>
<p>:param cohort:
The cohort function (lx).</p>
<p>:param age:
The age of the individual.</p>
<p>:param kind:
Type of life expectancy calculated. "Complete" or "curtate" can be computed.</p>
<p>:return: The life expectancy of the individual aged x.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def life_expectancy(self, cohort, age=0, kind: str = &#39;complete&#39;):  # exn
    &#34;&#34;&#34;
    This function computes the life expectancy at ages x.

    :param cohort:  The cohort function (lx).

    :param age:  The age of the individual.

    :param kind:  Type of life expectancy calculated. &#34;Complete&#34; or &#34;curtate&#34; can be computed.

    :return: The life expectancy of the individual aged x.

    &#34;&#34;&#34;

    t = pd.Series(np.arange(1, (120 - age + 1)))
    c1 = (cohort[age + t].sum()) / cohort[age]
    if kind == &#39;complete&#39;:
        return c1.round(2) + .5
    elif kind == &#39;curtate&#39;:
        return c1.round(2)
    else:
        print(&#39;Error. Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="telma.BiometricModel.omega"><code class="name flex">
<span>def <span class="ident">omega</span></span>(<span>self, cohort1, cohort2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Older age of the cohort. This value is known as Actuarial Infinity
and it is denotes with omega: ω</p>
<p>:param cohort2: Array-like The cohort function (lx).</p>
<p>:param cohort1: Array-like The cohort function (lx).</p>
<p>:return: Last age of the cohort. It is assumed that the index is age-based.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def omega(self, cohort1, cohort2=None):
    &#34;&#34;&#34;
    Older age of the cohort. This value is known as Actuarial Infinity
    and it is denotes with omega: \u03C9

    :param cohort2: Array-like The cohort function (lx).

    :param cohort1: Array-like The cohort function (lx).

    :return: Last age of the cohort. It is assumed that the index is age-based.
    &#34;&#34;&#34;

    omega1, omega2 = 0, 0
    if int(cohort1[-1:]) != 0:
        omega1 = cohort1.index[-1] + 1
    else:
        omega1 = cohort1.index[-1]
    if cohort2 is not None:
        if int(cohort1[-1:]) != 0:
            omega1 = cohort1.index[-1] + 1
        else:
            omega1 = cohort1.index[-1]
        if int(cohort2[-1:]) != 0:
            omega2 = cohort2.index[-1] + 1
        else:
            omega2 = cohort2.index[-1]
        return omega1, omega2
    return omega1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="telma.Datasets"><code class="flex name class">
<span>class <span class="ident">Datasets</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class contains some dataset for carrying out calculations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Datasets:
    &#34;&#34;&#34;
    This class contains some dataset for carrying out calculations
    &#34;&#34;&#34;

    def PER2020_Col_1er_orden(self):
        &#34;&#34;&#34;
        Las PER2020. Tablas generacionales. Se usan para el càlculo de las rentas de supervivencia.
        :return: The PER2020_Col. tabla
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/PER2020_Col_1er.orden.csv&#39;
        data = pd.read_csv(f)
        return data

    def Pasem2020(self):
        &#34;&#34;&#34;
        The PASEM TABLA. Tablas no generacionales. Se usan para el seguro de fallecimiento.
        :return: PASEM2020
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/SpainTables.csv&#39;
        data = pd.read_csv(f)
        return data

    def lifeTables(self):
        &#34;&#34;&#34;

        :return:
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/lifeTable.csv&#39;
        data = pd.read_csv(f, index_col=0)
        return data

    def PER2020_Ind_2ndo_orden(self):
        &#34;&#34;&#34;
        Tablas del 2 orden.
        :return:
        &#34;&#34;&#34;
        f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/PER2020_Ind_2ndo.orden.csv&#39;
        data = pd.read_csv(f)
        return data

    def Italians_sim92(self):
        &#34;&#34;&#34;
        SIM92 a numeric vector, 1992 cross section general population males life table
        :return: Old Italian cohort vector
        &#34;&#34;&#34;
        f = &#39;https://github.com/Joevalencia/telma/blob/main/telma/italiani.csv&#39;
        data = pd.read_csv(f).x
        return data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="telma.Datasets.Italians_sim92"><code class="name flex">
<span>def <span class="ident">Italians_sim92</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>SIM92 a numeric vector, 1992 cross section general population males life table
:return: Old Italian cohort vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Italians_sim92(self):
    &#34;&#34;&#34;
    SIM92 a numeric vector, 1992 cross section general population males life table
    :return: Old Italian cohort vector
    &#34;&#34;&#34;
    f = &#39;https://github.com/Joevalencia/telma/blob/main/telma/italiani.csv&#39;
    data = pd.read_csv(f).x
    return data</code></pre>
</details>
</dd>
<dt id="telma.Datasets.PER2020_Col_1er_orden"><code class="name flex">
<span>def <span class="ident">PER2020_Col_1er_orden</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Las PER2020. Tablas generacionales. Se usan para el càlculo de las rentas de supervivencia.
:return: The PER2020_Col. tabla</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PER2020_Col_1er_orden(self):
    &#34;&#34;&#34;
    Las PER2020. Tablas generacionales. Se usan para el càlculo de las rentas de supervivencia.
    :return: The PER2020_Col. tabla
    &#34;&#34;&#34;
    f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/PER2020_Col_1er.orden.csv&#39;
    data = pd.read_csv(f)
    return data</code></pre>
</details>
</dd>
<dt id="telma.Datasets.PER2020_Ind_2ndo_orden"><code class="name flex">
<span>def <span class="ident">PER2020_Ind_2ndo_orden</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tablas del 2 orden.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PER2020_Ind_2ndo_orden(self):
    &#34;&#34;&#34;
    Tablas del 2 orden.
    :return:
    &#34;&#34;&#34;
    f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/PER2020_Ind_2ndo.orden.csv&#39;
    data = pd.read_csv(f)
    return data</code></pre>
</details>
</dd>
<dt id="telma.Datasets.Pasem2020"><code class="name flex">
<span>def <span class="ident">Pasem2020</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The PASEM TABLA. Tablas no generacionales. Se usan para el seguro de fallecimiento.
:return: PASEM2020</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Pasem2020(self):
    &#34;&#34;&#34;
    The PASEM TABLA. Tablas no generacionales. Se usan para el seguro de fallecimiento.
    :return: PASEM2020
    &#34;&#34;&#34;
    f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/SpainTables.csv&#39;
    data = pd.read_csv(f)
    return data</code></pre>
</details>
</dd>
<dt id="telma.Datasets.lifeTables"><code class="name flex">
<span>def <span class="ident">lifeTables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lifeTables(self):
    &#34;&#34;&#34;

    :return:
    &#34;&#34;&#34;
    f = &#39;https://raw.githubusercontent.com/Joevalencia/telma/main/telma/lifeTable.csv&#39;
    data = pd.read_csv(f, index_col=0)
    return data</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="telma.InsuranceBenefits"><code class="flex name class">
<span>class <span class="ident">InsuranceBenefits</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class computes basic actuarial operation such as annuity and life insurance.</p>
<p>It can also computes commutations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InsuranceBenefits:

    &#34;&#34;&#34;

    This class computes basic actuarial operation such as annuity and life insurance.

    It can also computes commutations.

    &#34;&#34;&#34;

    def pure_endowment(self, cohort, age: int, n: int = 1,
                       i: float = .02, capital: float = 1):  # Exn
        &#34;&#34;&#34;
        Function to evaluate the pure endowment.

        Funciòn que evalua el Dotal Puro o Capital diferifo.

        :param capital: Int or Float. The capital.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. It is the age of the insured.

        :param n: Int. Length of the contract.

        :param i: Interest Rate.

        :return: The Actuarial Present Value of the contract and the probability Exn.

        &#34;&#34;&#34;

        time = n
        factor = 1 / (1 + i) ** time
        s = age + time
        probability = np.roll(cohort[s], 1) / cohort[age]
        n_ex = round(factor * probability, 7)
        endow = n_ex * capital
        print(f&#39;The Pure Endowment and value for an individual aged {age} \n&#39;
              f&#39;with a length contract of {time} given {capital} bucks is:\n&#39;)
        return round(endow, 2), n_ex  # Value of Pure Endowment without calculation

    def increasing_annuity(self, cohort, x, m=0, i=.02,
                           payments: str = &#39;advance&#39;):

        &#34;&#34;&#34;

        This function evaluates increasing annuities.

        :param cohort: The cohort function (lx).

        :param x: The age of insured

        :param m: The deferred period.

        :param i: Interest Rate.

        :param payments: The kind of increasing annuity. &#34;advance&#34; or &#34;arrears&#34; are accepted.

        :return:  The increasing annuity (advance or arrears).

        &#34;&#34;&#34;
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        # Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))

        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        if payments == &#39;advance&#39;:
            iaxn = (Sx[x + m]) / Dx[x]
        elif payments == &#39;arrears&#39;:
            iaxn = (Sx[x + m + 1]) / Dx[x]
        return iaxn

    def increasing_lifeinsurance(self, cohort, age, n=0, m=0, i=.02, kind=&#39;whole&#39;):

        &#34;&#34;&#34;

        :param cohort: The cohort function (lx).

        :param age: The age of insured

        :param n: The time of evaluation.

        :param m: The deferred period.

        :param i: Interest Rate.

        :param kind: The kind of increasing life insurance. &#34;Whole&#34; or &#34;Temporary&#34; are accepted.

        :return: The increasing life insurance.

        &#34;&#34;&#34;
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))
        if kind == &#39;whole&#39;:
            ias = Rx[age + m] / Dx[age]
            return round(ias, 6)
        elif kind == &#39;temporary&#39;:
            ias = (Rx[age + m] - Rx[age + n + m] - n * Mx[age + n + m]) / Dx[age]
            return round(ias, 6)
        else:
            print(&#39;Error! &#34;Kind&#34; can be &#34;whole&#34; or &#34;temporary&#34; either&#39;)

    def decreasing_annuity(self, cohort, age, m=0, n=1, i=.02, payments=&#39;advance&#39;):

        &#34;&#34;&#34;

        :param cohort: The cohort function (lx).

        :param age: The age of insured

        :param n: The time of evaluation.

        :param m: The deferred period.

        :param i: Interest Rate.

        :param payments: The kind of payments. It can be &#34;advance&#34; or &#34;arrears&#34;.

        :return: The decreasing annuity.

        &#34;&#34;&#34;

        x = age
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))

        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))

        if payments == &#39;advance&#39;:
            daxn = ((n * Nx[x]) - (Sx[x + m + 1] - Sx[x + m + n + 1])) / Dx[x]
        elif payments == &#39;arrears&#39;:
            daxn = ((n * Nx[x + 1]) - (Sx[x + m + 2] - Sx[x + m + n + 2])) / Dx[x]
        else:
            print(&#39;Error! Insert right &#34;advance&#34; or &#34;arrears&#34; &#39;)
        return daxn

    def temporary_annuity(self, cohort, age: int, n: int = &#39;whole&#39;, m=1,
                          i: float = .02, capital: float = 1, payments: str = &#39;advance&#39;):  # axn

        &#34;&#34;&#34;

        Temporary annuity function.
        Annuity advance and arrears can be evaluated.
        This function calculates actuarial value of annuities, given a cohort.
        Por defecto càlcula la annuity-advance, puede pasarsele la arrears.

        :param capital: Int or Float. The capital.

        :param payments: The kind of annuity &#34;arrears&#34; or &#34;advance&#34;.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. It is the age of the insured.

        :param n: Int. Length of the contract. If missing is assumed until omega.

        :param m: Number of fractional payments per period. By default 1.

        :param i: Interest Rate.

        :return: Temporary annuity.

        &#34;&#34;&#34;

        def omegas():
            omega1 = 0

            if int(cohort[-1:]) != 0:
                omega1 = cohort.index[-1] + 1
            else:
                omega1 = cohort.index[-1]
            return omega1

        # omegas()
        if n != &#39;whole&#39;:
            n = n
        elif n == &#39;whole&#39;:
            n = omegas() - (age + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)

        ## Imprentando tomar la temporalidad
        time = n
        Dx = (1 + i) ** (-cohort.index) * cohort
        w = len(Dx)
        nex = Dx[age + n] / Dx[age]  ## Dotal Puro
        konstante = (m - 1) / (2 * m)
        Nx = []
        for valor in range(0, w):
            Nx.append(sum(Dx[valor:]))

        if payments == &#39;arrears&#39;:
            print(&#39;The actuarial value of this annuity-arrears is:&#39;)
            axn = (Nx[age + 1] - Nx[age + time + 1]) / Dx[age]
            axn1 = axn + konstante * (1 - nex)  ## Using Approximation
            return round(axn1 * capital, 5)
        elif payments == &#39;advance&#39;:
            print(&#39;The actuarial value of this annuity-advance is:&#39;)
            axn2 = (Nx[age] - Nx[age + time]) / Dx[age]
            axn3 = axn2 - konstante * (1 - nex)  ## Using Approximation
            return round(axn3 * capital, 5)
        else:
            print(&#39;Payments parameter should be advance (default) or arrears either&#39;)

    def deferred_annuity(self, cohort, age: int, n: int = 10,
                         m: int = 5, i: float = .02, capital: float = 1,
                         payments=&#39;advance&#39;):
        &#34;&#34;&#34;

        :param capital: Float. The capital.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. It is the age of the insured.

        :param n: Int. Length of the contract.

        :param m: Int. The deferred period.

        :param i: Interest Rate.

        :param payments:  The kind

        :return:

        &#34;&#34;&#34;

        time = n
        Dx = (1 + i) ** (-cohort.index) * cohort
        n = len(Dx)
        Nx = []
        for valor in range(0, n):
            Nx.append(sum(Dx[valor:]))
        if payments == &#39;arrears&#39;:
            axn = (Nx[age + m + 1] - Nx[age + m + time + 1]) / Dx[age]
            return round(axn * capital, 5)
        elif payments == &#39;advance&#39;:
            axn2 = (Nx[age + m] - Nx[age + m + time]) / Dx[age]
            return round(axn2 * capital, 5)
        elif payments == &#39;whole arrears&#39;:
            axn3 = Nx[age + m + 1] / Dx[age]
            return round(axn3 * capital, 5)
        elif payments == &#39;whole advance&#39;:
            axn3 = Nx[age + m] / Dx[age]
            return round(axn3 * capital, 5)
        else:
            print(&#39;Please the payments should be specified as &#34;advance&#34;, &#34;arrears&#34;, &#34;whole advance&#34; or &#39;
                  &#39;&#34;whole arrears&#34; either&#39;)

    def commutations(self, cohort, i: float = .02):
        &#34;&#34;&#34;

        Tabulates the actuarial commutation functions.

        Calcula las communtaciones dada una coorte y tasa i.

        :param cohort: The cohort function (lx).

        :param i: Float. Interest Rate.

        :return: The table of commutations given i (rate).

        &#34;&#34;&#34;

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))

        df = pd.DataFrame({&#39;lx&#39;: cohort, &#39;Dx&#39;: Dx, &#39;Nx&#39;: Nx,
                           &#39;Cx&#39;: Cx, &#39;Mx&#39;: Mx, &#39;Rx&#39;: Rx, &#39;Sx&#39;: Sx})
        print(&#39;--&#39; * 25)
        print(f&#39;Commutations results of {cohort.name}:&#39;)
        print(&#39;--&#39; * 25)
        print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
        print(&#39;Region and Country: &#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
        return df  ## Commutations

    def endowment(self, cohort, age: int, t: int = 1, i: float = .02,
                  capital: float = 1):  # AExn
        &#34;&#34;&#34;

        Function to evaluate the n-year endowment insurance.

        :param cohort: The cohort function (lx).

        :param age: Int. Age of the insured.

        :param t: The length of the contract.

        :param i: Interest Rate.

        :param capital: Float. The capital of the operation.

        :return:  The endowment.

        &#34;&#34;&#34;
        time = t
        fee = capital
        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        pagamento = (Mx[age] - Mx[age + time] + Dx[age + time]) / Dx[age]
        tariffa = round(pagamento * fee, 2)
        print(f&#39;The endowment of age {age}: is {tariffa} and his probability is {pagamento}&#39;)
        return tariffa

    def tincreasing_annuity(self, cohort, x, m=0, n=1, i=.02,
                            payments: str = &#39;advance&#39;):  ## m deferred period.

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))

        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))

        if payments == &#39;advance&#39;:
            iaxn = (Sx[x + m] - Sx[x + n + m] - n * Nx[x + n + m]) / Dx[x]
        elif payments == &#39;arrears&#39;:
            iaxn = (Sx[x + m] - Sx[x + m + n + 1] - n * Nx[x + n + m + 1]) / Dx[x]
        return iaxn

    def whole_life_insurance(self, cohort, age, i: float = .02,
                             capital: float = 1, kind: str = &#39;whole&#39;):
        &#34;&#34;&#34;

         A payment of 1 is made at the end of the year of death of a person
            aged x.

        :param cohort: The cohort function (lx).

        :param age: The Age of the individual.

        :param i: Interest Rate.

        :param capital: The capital of the operation.

        :param kind: The kind of life insurance contract. &#34;Whole&#34; or &#34;Immediate&#34;.

        :return:  The present value of the payment of the whole life insurance.

        &#34;&#34;&#34;

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))

        if kind == &#39;immediate&#39;:
            v = (1 + i) ** .5
            insurance = v * Mx[age] / Dx[age]
        elif kind == &#39;whole&#39;:
            insurance = Mx[age] / Dx[age]
        else:
            print(&#39;Only &#34;whole&#34; and &#34;immediate&#34; are accepted!&#39;)

        return round(insurance * capital, 7)

    def temporary_insurance(self, cohort, age, m: int = 0, n: int = 1, i: float = .02,
                            capital: float = 1):
        &#34;&#34;&#34;

        A payment of 1 is made at the end of the year of death of a
        person aged x provided the person dies within n years.

        :param cohort: The cohort function (lx).

        :param age: The age of the individual.

        :param m: The deferred period.

        :param n: Period until which the age should be evaluated.

        :param i: Interest Rate.

        :param capital: The capital.

        :return: The present value of the payments.

        &#34;&#34;&#34;

        dx = (cohort - cohort.shift(-1)).fillna(0)
        indice = pd.Series(range(1, len(cohort))).fillna(0)
        Cx = ((1 + i) ** (-indice) * dx).fillna(0)
        Dx = (1 + i) ** (-cohort.index) * cohort

        Nx = []
        for valor in range(0, len(Dx)):
            Nx.append(sum(Dx[valor:]))
        Mx = []
        for x in range(0, len(Cx)):
            Mx.append(sum(Cx[x:-1]))
        Sx = []
        for s in range(0, len(Nx)):
            Sx.append(sum(Nx[s:]))
        Rx = []
        for r in range(0, len(Mx)):
            Rx.append(sum(Mx[r:]))

        insurance = (Mx[age + m] - Mx[age + m + n]) / Dx[age]

        return round(insurance * capital, 5)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="telma.InsuranceBenefits.commutations"><code class="name flex">
<span>def <span class="ident">commutations</span></span>(<span>self, cohort, i: float = 0.02)</span>
</code></dt>
<dd>
<div class="desc"><p>Tabulates the actuarial commutation functions.</p>
<p>Calcula las communtaciones dada una coorte y tasa i.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param i: Float. Interest Rate.</p>
<p>:return: The table of commutations given i (rate).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commutations(self, cohort, i: float = .02):
    &#34;&#34;&#34;

    Tabulates the actuarial commutation functions.

    Calcula las communtaciones dada una coorte y tasa i.

    :param cohort: The cohort function (lx).

    :param i: Float. Interest Rate.

    :return: The table of commutations given i (rate).

    &#34;&#34;&#34;

    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort

    Nx = []
    for valor in range(0, len(Dx)):
        Nx.append(sum(Dx[valor:]))
    Mx = []
    for x in range(0, len(Cx)):
        Mx.append(sum(Cx[x:-1]))
    Sx = []
    for s in range(0, len(Nx)):
        Sx.append(sum(Nx[s:]))
    Rx = []
    for r in range(0, len(Mx)):
        Rx.append(sum(Mx[r:]))

    df = pd.DataFrame({&#39;lx&#39;: cohort, &#39;Dx&#39;: Dx, &#39;Nx&#39;: Nx,
                       &#39;Cx&#39;: Cx, &#39;Mx&#39;: Mx, &#39;Rx&#39;: Rx, &#39;Sx&#39;: Sx})
    print(&#39;--&#39; * 25)
    print(f&#39;Commutations results of {cohort.name}:&#39;)
    print(&#39;--&#39; * 25)
    print(&#39;Date and Time: &#39;, strftime(&#34;%a, %d %b %Y %H:%M:%S&#34;))
    print(&#39;Region and Country: &#39;, geo_json[&#39;region&#39;], &#39;,&#39;, geo_json[&#39;country&#39;])
    return df  ## Commutations</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.decreasing_annuity"><code class="name flex">
<span>def <span class="ident">decreasing_annuity</span></span>(<span>self, cohort, age, m=0, n=1, i=0.02, payments='advance')</span>
</code></dt>
<dd>
<div class="desc"><p>:param cohort: The cohort function (lx).</p>
<p>:param age: The age of insured</p>
<p>:param n: The time of evaluation.</p>
<p>:param m: The deferred period.</p>
<p>:param i: Interest Rate.</p>
<p>:param payments: The kind of payments. It can be "advance" or "arrears".</p>
<p>:return: The decreasing annuity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decreasing_annuity(self, cohort, age, m=0, n=1, i=.02, payments=&#39;advance&#39;):

    &#34;&#34;&#34;

    :param cohort: The cohort function (lx).

    :param age: The age of insured

    :param n: The time of evaluation.

    :param m: The deferred period.

    :param i: Interest Rate.

    :param payments: The kind of payments. It can be &#34;advance&#34; or &#34;arrears&#34;.

    :return: The decreasing annuity.

    &#34;&#34;&#34;

    x = age
    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort

    Nx = []
    for valor in range(0, len(Dx)):
        Nx.append(sum(Dx[valor:]))

    Sx = []
    for s in range(0, len(Nx)):
        Sx.append(sum(Nx[s:]))

    if payments == &#39;advance&#39;:
        daxn = ((n * Nx[x]) - (Sx[x + m + 1] - Sx[x + m + n + 1])) / Dx[x]
    elif payments == &#39;arrears&#39;:
        daxn = ((n * Nx[x + 1]) - (Sx[x + m + 2] - Sx[x + m + n + 2])) / Dx[x]
    else:
        print(&#39;Error! Insert right &#34;advance&#34; or &#34;arrears&#34; &#39;)
    return daxn</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.deferred_annuity"><code class="name flex">
<span>def <span class="ident">deferred_annuity</span></span>(<span>self, cohort, age: int, n: int = 10, m: int = 5, i: float = 0.02, capital: float = 1, payments='advance')</span>
</code></dt>
<dd>
<div class="desc"><p>:param capital: Float. The capital.</p>
<p>:param cohort: Array-like. The cohort function (lx).</p>
<p>:param age: Int. It is the age of the insured.</p>
<p>:param n: Int. Length of the contract.</p>
<p>:param m: Int. The deferred period.</p>
<p>:param i: Interest Rate.</p>
<p>:param payments:
The kind</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deferred_annuity(self, cohort, age: int, n: int = 10,
                     m: int = 5, i: float = .02, capital: float = 1,
                     payments=&#39;advance&#39;):
    &#34;&#34;&#34;

    :param capital: Float. The capital.

    :param cohort: Array-like. The cohort function (lx).

    :param age: Int. It is the age of the insured.

    :param n: Int. Length of the contract.

    :param m: Int. The deferred period.

    :param i: Interest Rate.

    :param payments:  The kind

    :return:

    &#34;&#34;&#34;

    time = n
    Dx = (1 + i) ** (-cohort.index) * cohort
    n = len(Dx)
    Nx = []
    for valor in range(0, n):
        Nx.append(sum(Dx[valor:]))
    if payments == &#39;arrears&#39;:
        axn = (Nx[age + m + 1] - Nx[age + m + time + 1]) / Dx[age]
        return round(axn * capital, 5)
    elif payments == &#39;advance&#39;:
        axn2 = (Nx[age + m] - Nx[age + m + time]) / Dx[age]
        return round(axn2 * capital, 5)
    elif payments == &#39;whole arrears&#39;:
        axn3 = Nx[age + m + 1] / Dx[age]
        return round(axn3 * capital, 5)
    elif payments == &#39;whole advance&#39;:
        axn3 = Nx[age + m] / Dx[age]
        return round(axn3 * capital, 5)
    else:
        print(&#39;Please the payments should be specified as &#34;advance&#34;, &#34;arrears&#34;, &#34;whole advance&#34; or &#39;
              &#39;&#34;whole arrears&#34; either&#39;)</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.endowment"><code class="name flex">
<span>def <span class="ident">endowment</span></span>(<span>self, cohort, age: int, t: int = 1, i: float = 0.02, capital: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to evaluate the n-year endowment insurance.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param age: Int. Age of the insured.</p>
<p>:param t: The length of the contract.</p>
<p>:param i: Interest Rate.</p>
<p>:param capital: Float. The capital of the operation.</p>
<p>:return:
The endowment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endowment(self, cohort, age: int, t: int = 1, i: float = .02,
              capital: float = 1):  # AExn
    &#34;&#34;&#34;

    Function to evaluate the n-year endowment insurance.

    :param cohort: The cohort function (lx).

    :param age: Int. Age of the insured.

    :param t: The length of the contract.

    :param i: Interest Rate.

    :param capital: Float. The capital of the operation.

    :return:  The endowment.

    &#34;&#34;&#34;
    time = t
    fee = capital
    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort
    Mx = []
    for x in range(0, len(Cx)):
        Mx.append(sum(Cx[x:-1]))
    pagamento = (Mx[age] - Mx[age + time] + Dx[age + time]) / Dx[age]
    tariffa = round(pagamento * fee, 2)
    print(f&#39;The endowment of age {age}: is {tariffa} and his probability is {pagamento}&#39;)
    return tariffa</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.increasing_annuity"><code class="name flex">
<span>def <span class="ident">increasing_annuity</span></span>(<span>self, cohort, x, m=0, i=0.02, payments: str = 'advance')</span>
</code></dt>
<dd>
<div class="desc"><p>This function evaluates increasing annuities.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param x: The age of insured</p>
<p>:param m: The deferred period.</p>
<p>:param i: Interest Rate.</p>
<p>:param payments: The kind of increasing annuity. "advance" or "arrears" are accepted.</p>
<p>:return:
The increasing annuity (advance or arrears).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increasing_annuity(self, cohort, x, m=0, i=.02,
                       payments: str = &#39;advance&#39;):

    &#34;&#34;&#34;

    This function evaluates increasing annuities.

    :param cohort: The cohort function (lx).

    :param x: The age of insured

    :param m: The deferred period.

    :param i: Interest Rate.

    :param payments: The kind of increasing annuity. &#34;advance&#34; or &#34;arrears&#34; are accepted.

    :return:  The increasing annuity (advance or arrears).

    &#34;&#34;&#34;
    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    # Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort

    Nx = []
    for valor in range(0, len(Dx)):
        Nx.append(sum(Dx[valor:]))

    Sx = []
    for s in range(0, len(Nx)):
        Sx.append(sum(Nx[s:]))
    if payments == &#39;advance&#39;:
        iaxn = (Sx[x + m]) / Dx[x]
    elif payments == &#39;arrears&#39;:
        iaxn = (Sx[x + m + 1]) / Dx[x]
    return iaxn</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.increasing_lifeinsurance"><code class="name flex">
<span>def <span class="ident">increasing_lifeinsurance</span></span>(<span>self, cohort, age, n=0, m=0, i=0.02, kind='whole')</span>
</code></dt>
<dd>
<div class="desc"><p>:param cohort: The cohort function (lx).</p>
<p>:param age: The age of insured</p>
<p>:param n: The time of evaluation.</p>
<p>:param m: The deferred period.</p>
<p>:param i: Interest Rate.</p>
<p>:param kind: The kind of increasing life insurance. "Whole" or "Temporary" are accepted.</p>
<p>:return: The increasing life insurance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increasing_lifeinsurance(self, cohort, age, n=0, m=0, i=.02, kind=&#39;whole&#39;):

    &#34;&#34;&#34;

    :param cohort: The cohort function (lx).

    :param age: The age of insured

    :param n: The time of evaluation.

    :param m: The deferred period.

    :param i: Interest Rate.

    :param kind: The kind of increasing life insurance. &#34;Whole&#34; or &#34;Temporary&#34; are accepted.

    :return: The increasing life insurance.

    &#34;&#34;&#34;
    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort

    Nx = []
    for valor in range(0, len(Dx)):
        Nx.append(sum(Dx[valor:]))
    Mx = []
    for x in range(0, len(Cx)):
        Mx.append(sum(Cx[x:-1]))
    Sx = []
    for s in range(0, len(Nx)):
        Sx.append(sum(Nx[s:]))
    Rx = []
    for r in range(0, len(Mx)):
        Rx.append(sum(Mx[r:]))
    if kind == &#39;whole&#39;:
        ias = Rx[age + m] / Dx[age]
        return round(ias, 6)
    elif kind == &#39;temporary&#39;:
        ias = (Rx[age + m] - Rx[age + n + m] - n * Mx[age + n + m]) / Dx[age]
        return round(ias, 6)
    else:
        print(&#39;Error! &#34;Kind&#34; can be &#34;whole&#34; or &#34;temporary&#34; either&#39;)</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.pure_endowment"><code class="name flex">
<span>def <span class="ident">pure_endowment</span></span>(<span>self, cohort, age: int, n: int = 1, i: float = 0.02, capital: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to evaluate the pure endowment.</p>
<p>Funciòn que evalua el Dotal Puro o Capital diferifo.</p>
<p>:param capital: Int or Float. The capital.</p>
<p>:param cohort: Array-like. The cohort function (lx).</p>
<p>:param age: Int. It is the age of the insured.</p>
<p>:param n: Int. Length of the contract.</p>
<p>:param i: Interest Rate.</p>
<p>:return: The Actuarial Present Value of the contract and the probability Exn.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pure_endowment(self, cohort, age: int, n: int = 1,
                   i: float = .02, capital: float = 1):  # Exn
    &#34;&#34;&#34;
    Function to evaluate the pure endowment.

    Funciòn que evalua el Dotal Puro o Capital diferifo.

    :param capital: Int or Float. The capital.

    :param cohort: Array-like. The cohort function (lx).

    :param age: Int. It is the age of the insured.

    :param n: Int. Length of the contract.

    :param i: Interest Rate.

    :return: The Actuarial Present Value of the contract and the probability Exn.

    &#34;&#34;&#34;

    time = n
    factor = 1 / (1 + i) ** time
    s = age + time
    probability = np.roll(cohort[s], 1) / cohort[age]
    n_ex = round(factor * probability, 7)
    endow = n_ex * capital
    print(f&#39;The Pure Endowment and value for an individual aged {age} \n&#39;
          f&#39;with a length contract of {time} given {capital} bucks is:\n&#39;)
    return round(endow, 2), n_ex  # Value of Pure Endowment without calculation</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.temporary_annuity"><code class="name flex">
<span>def <span class="ident">temporary_annuity</span></span>(<span>self, cohort, age: int, n: int = 'whole', m=1, i: float = 0.02, capital: float = 1, payments: str = 'advance')</span>
</code></dt>
<dd>
<div class="desc"><p>Temporary annuity function.
Annuity advance and arrears can be evaluated.
This function calculates actuarial value of annuities, given a cohort.
Por defecto càlcula la annuity-advance, puede pasarsele la arrears.</p>
<p>:param capital: Int or Float. The capital.</p>
<p>:param payments: The kind of annuity "arrears" or "advance".</p>
<p>:param cohort: Array-like. The cohort function (lx).</p>
<p>:param age: Int. It is the age of the insured.</p>
<p>:param n: Int. Length of the contract. If missing is assumed until omega.</p>
<p>:param m: Number of fractional payments per period. By default 1.</p>
<p>:param i: Interest Rate.</p>
<p>:return: Temporary annuity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temporary_annuity(self, cohort, age: int, n: int = &#39;whole&#39;, m=1,
                      i: float = .02, capital: float = 1, payments: str = &#39;advance&#39;):  # axn

    &#34;&#34;&#34;

    Temporary annuity function.
    Annuity advance and arrears can be evaluated.
    This function calculates actuarial value of annuities, given a cohort.
    Por defecto càlcula la annuity-advance, puede pasarsele la arrears.

    :param capital: Int or Float. The capital.

    :param payments: The kind of annuity &#34;arrears&#34; or &#34;advance&#34;.

    :param cohort: Array-like. The cohort function (lx).

    :param age: Int. It is the age of the insured.

    :param n: Int. Length of the contract. If missing is assumed until omega.

    :param m: Number of fractional payments per period. By default 1.

    :param i: Interest Rate.

    :return: Temporary annuity.

    &#34;&#34;&#34;

    def omegas():
        omega1 = 0

        if int(cohort[-1:]) != 0:
            omega1 = cohort.index[-1] + 1
        else:
            omega1 = cohort.index[-1]
        return omega1

    # omegas()
    if n != &#39;whole&#39;:
        n = n
    elif n == &#39;whole&#39;:
        n = omegas() - (age + m)
    else:
        print(&#39;Error! Type a new &#34;n&#34; &#39;)

    ## Imprentando tomar la temporalidad
    time = n
    Dx = (1 + i) ** (-cohort.index) * cohort
    w = len(Dx)
    nex = Dx[age + n] / Dx[age]  ## Dotal Puro
    konstante = (m - 1) / (2 * m)
    Nx = []
    for valor in range(0, w):
        Nx.append(sum(Dx[valor:]))

    if payments == &#39;arrears&#39;:
        print(&#39;The actuarial value of this annuity-arrears is:&#39;)
        axn = (Nx[age + 1] - Nx[age + time + 1]) / Dx[age]
        axn1 = axn + konstante * (1 - nex)  ## Using Approximation
        return round(axn1 * capital, 5)
    elif payments == &#39;advance&#39;:
        print(&#39;The actuarial value of this annuity-advance is:&#39;)
        axn2 = (Nx[age] - Nx[age + time]) / Dx[age]
        axn3 = axn2 - konstante * (1 - nex)  ## Using Approximation
        return round(axn3 * capital, 5)
    else:
        print(&#39;Payments parameter should be advance (default) or arrears either&#39;)</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.temporary_insurance"><code class="name flex">
<span>def <span class="ident">temporary_insurance</span></span>(<span>self, cohort, age, m: int = 0, n: int = 1, i: float = 0.02, capital: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>A payment of 1 is made at the end of the year of death of a
person aged x provided the person dies within n years.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param age: The age of the individual.</p>
<p>:param m: The deferred period.</p>
<p>:param n: Period until which the age should be evaluated.</p>
<p>:param i: Interest Rate.</p>
<p>:param capital: The capital.</p>
<p>:return: The present value of the payments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temporary_insurance(self, cohort, age, m: int = 0, n: int = 1, i: float = .02,
                        capital: float = 1):
    &#34;&#34;&#34;

    A payment of 1 is made at the end of the year of death of a
    person aged x provided the person dies within n years.

    :param cohort: The cohort function (lx).

    :param age: The age of the individual.

    :param m: The deferred period.

    :param n: Period until which the age should be evaluated.

    :param i: Interest Rate.

    :param capital: The capital.

    :return: The present value of the payments.

    &#34;&#34;&#34;

    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort

    Nx = []
    for valor in range(0, len(Dx)):
        Nx.append(sum(Dx[valor:]))
    Mx = []
    for x in range(0, len(Cx)):
        Mx.append(sum(Cx[x:-1]))
    Sx = []
    for s in range(0, len(Nx)):
        Sx.append(sum(Nx[s:]))
    Rx = []
    for r in range(0, len(Mx)):
        Rx.append(sum(Mx[r:]))

    insurance = (Mx[age + m] - Mx[age + m + n]) / Dx[age]

    return round(insurance * capital, 5)</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.tincreasing_annuity"><code class="name flex">
<span>def <span class="ident">tincreasing_annuity</span></span>(<span>self, cohort, x, m=0, n=1, i=0.02, payments: str = 'advance')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tincreasing_annuity(self, cohort, x, m=0, n=1, i=.02,
                        payments: str = &#39;advance&#39;):  ## m deferred period.

    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort

    Nx = []
    for valor in range(0, len(Dx)):
        Nx.append(sum(Dx[valor:]))

    Sx = []
    for s in range(0, len(Nx)):
        Sx.append(sum(Nx[s:]))

    if payments == &#39;advance&#39;:
        iaxn = (Sx[x + m] - Sx[x + n + m] - n * Nx[x + n + m]) / Dx[x]
    elif payments == &#39;arrears&#39;:
        iaxn = (Sx[x + m] - Sx[x + m + n + 1] - n * Nx[x + n + m + 1]) / Dx[x]
    return iaxn</code></pre>
</details>
</dd>
<dt id="telma.InsuranceBenefits.whole_life_insurance"><code class="name flex">
<span>def <span class="ident">whole_life_insurance</span></span>(<span>self, cohort, age, i: float = 0.02, capital: float = 1, kind: str = 'whole')</span>
</code></dt>
<dd>
<div class="desc"><p>A payment of 1 is made at the end of the year of death of a person
aged x.</p>
<p>:param cohort: The cohort function (lx).</p>
<p>:param age: The Age of the individual.</p>
<p>:param i: Interest Rate.</p>
<p>:param capital: The capital of the operation.</p>
<p>:param kind: The kind of life insurance contract. "Whole" or "Immediate".</p>
<p>:return:
The present value of the payment of the whole life insurance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def whole_life_insurance(self, cohort, age, i: float = .02,
                         capital: float = 1, kind: str = &#39;whole&#39;):
    &#34;&#34;&#34;

     A payment of 1 is made at the end of the year of death of a person
        aged x.

    :param cohort: The cohort function (lx).

    :param age: The Age of the individual.

    :param i: Interest Rate.

    :param capital: The capital of the operation.

    :param kind: The kind of life insurance contract. &#34;Whole&#34; or &#34;Immediate&#34;.

    :return:  The present value of the payment of the whole life insurance.

    &#34;&#34;&#34;

    dx = (cohort - cohort.shift(-1)).fillna(0)
    indice = pd.Series(range(1, len(cohort))).fillna(0)
    Cx = ((1 + i) ** (-indice) * dx).fillna(0)
    Dx = (1 + i) ** (-cohort.index) * cohort

    Nx = []
    for valor in range(0, len(Dx)):
        Nx.append(sum(Dx[valor:]))
    Mx = []
    for x in range(0, len(Cx)):
        Mx.append(sum(Cx[x:-1]))
    Sx = []
    for s in range(0, len(Nx)):
        Sx.append(sum(Nx[s:]))
    Rx = []
    for r in range(0, len(Mx)):
        Rx.append(sum(Mx[r:]))

    if kind == &#39;immediate&#39;:
        v = (1 + i) ** .5
        insurance = v * Mx[age] / Dx[age]
    elif kind == &#39;whole&#39;:
        insurance = Mx[age] / Dx[age]
    else:
        print(&#39;Only &#34;whole&#34; and &#34;immediate&#34; are accepted!&#39;)

    return round(insurance * capital, 7)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="telma.MultipleLives"><code class="flex name class">
<span>class <span class="ident">MultipleLives</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class refers to life actuarial basic calculation on one individual based on a given cohort (lx).</p>
<p>The life plot permits charting the cohort function in a static or dinamic mode either. (Plotly is required)
Furthemore is strongly advided inserting in "cohorte2" the cohort function that has a different length from
"cohort1" and "model".</p>
<p>See example in Jupyter examples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipleLives:
    &#34;&#34;&#34;
        This class refers to life actuarial basic calculation on one individual based on a given cohort (lx).

        The life plot permits charting the cohort function in a static or dinamic mode either. (Plotly is required)
        Furthemore is strongly advided inserting in &#34;cohorte2&#34; the cohort function that has a different length from
        &#34;cohort1&#34; and &#34;model&#34;.

        See example in Jupyter examples.

        &#34;&#34;&#34;

    def lifeplot_2(self, cohort1, cohorte2, model=None, interactive: bool = False, qx_log: bool = False,
                   death: bool = False):

        &#34;&#34;&#34;
        It plots the graph of multiple cohorts interactively or static either.

        :param cohort1: The cohort function (lx).

        :param cohorte2: The cohort function (ly).
                         If len(ly)&lt;len(x) please consider passing ly as cohorte.

        :param model: A third cohort function (lz).

        :param qx_log: If True it displays log(qx) cohorts using plotly.

        :param interactive: If True it displays cohorts interactively using plotly.

        :param death: If True it displays dx cohorts using plotly.

        :return: Living Plot, Log(qx) or dx either.

        &#34;&#34;&#34;

        ful = []  ## considerar poner como cohorte2 el vector que tiene diferente longitud en interactively
        if len(cohort1) != len(cohorte2):
            for i in range(abs(len(cohort1) - len(cohorte2))):
                ful.append(0)
            cohort2 = cohorte2.append(pd.Series(ful),
                                      ignore_index=True).astype(str(cohort1.dtype))

        else:
            cohort2 = cohorte2

        #
        px1 = (cohort1.shift(-1) / cohort1).fillna(0)
        px2 = (cohort2.shift(-1) / cohort2).fillna(0)
        qx1, qx2 = 1 - px1, 1 - px2
        dx1, dx2 = qx1 * cohort1, qx2 * cohort2
        qx22 = 1 - (cohorte2.shift(-1) / cohorte2).fillna(0)
        dx22 = qx22 * cohorte2

        e1 = []
        for i in range(0, len(cohort1[:-1])):
            ley = cohort1[i]
            e1.append(sum(cohort1[i + 1:-1]) / ley)
        eyx = pd.Series(e1) + .5

        e2 = []
        for i in range(0, len(cohort2[:-1])):
            ley = cohort2[i]
            e2.append(sum(cohort2[i + 1:-1]) / ley)
        eys = pd.Series(e2) + .5

        df1 = pd.DataFrame({f&#39;{cohort1.name}&#39;: cohort1, &#39;e\u20931&#39;: round(eyx, 2),
                            f&#39;{cohort2.name}&#39;: cohort2, &#39;e\u20932&#39;: round(eys, 2),
                            &#39;Age&#39;: cohort1.index, f&#39;Death {cohort1.name}&#39;: dx1,
                            f&#39;Death {cohort2.name}&#39;: dx2})

        if not interactive:
            plt.figure(figsize=(15, 5))
            p0 = plt.subplot(1, 2, 1)
            plt.title(f&#39;Survival Plot of {cohort1.name} &#39;
                      f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Living people ($l_{x}$) and ($l_{y}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 120])
            plt.plot(cohort1.index, cohort1, label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
            plt.plot(cohorte2.index, cohorte2, label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)
            # plt.legend()
            if model is not None:
                plt.plot(model.index, model, label=f&#39;{model.name}&#39;, color=&#39;red&#39;)
            plt.legend()
            p1 = plt.subplot(1, 2, 2)
            plt.title(f&#39;Death Plot of {cohort1.name} &#39;
                      f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Death people ($d_{x}$) and ($d_{y}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 120])
            if qx_log is True:
                plt.title(f&#39;LogDeath Plot of {cohort1.name} &#39;
                          f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
                plt.ylabel(&#39;LogDeath ($d_{x}$) and ($d_{y}$)&#39;, fontweight=&#39;bold&#39;)
                plt.plot(np.log(qx1), label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
                plt.plot(np.log(qx22), label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)
            else:
                plt.plot(dx1, label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
                plt.plot(dx22, label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)

            if model is not None:
                pxm = ((model / model.shift(1)).shift(-1)).fillna(0)
                qxm = 1 - pxm
                dxm = qxm * model

                if qx_log is True:
                    plt.plot(np.log(qxm.replace(0, 1)), label=f&#39;{model.name}&#39;, color=&#39;red&#39;)
                else:
                    plt.plot(dxm, label=f&#39;{model.name}&#39;, color=&#39;red&#39;)

            plt.legend()

            plt.show()

        else:
            import plotly.express as px
            if not death:
                fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;{cohort1.name}&#39;, f&#39;{cohort2.name}&#39;],
                              hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;],
                              title=f&#39;Survival plot of {cohort1.name} and {cohort2.name}&#39;)
            else:
                if qx_log is True:
                    fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;, f&#39;Death {cohort2.name}&#39;],
                                  hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;], log_y=True,
                                  title=f&#39;LogDeath plot of {cohort1.name} and {cohort2.name}&#39;)
                else:
                    fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;, f&#39;Death {cohort2.name}&#39;],
                                  hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;],
                                  title=f&#39;Death plot of {cohort1.name} and {cohort2.name}&#39;)
            if model is not None:
                pxm = ((model / model.shift(1)).shift(-1)).fillna(0)
                qxm = 1 - pxm
                dxm = qxm * model
                em = []
                for s in range(0, len(model[:-1])):
                    luc = model[s]
                    em.append(sum(model[s + 1:-1]) / luc)
                emm = pd.Series(em) + .5
                df2 = pd.DataFrame({f&#39;{cohort1.name}&#39;: cohort1, f&#39;qx_{cohort1.name}&#39;: round(qx1, 7),
                                    f&#39;{cohort2.name}&#39;: cohort2, f&#39;qx_{cohort2.name}&#39;: round(qx2, 7),
                                    f&#39;{model.name}&#39;: model, f&#39;qx_{model.name}&#39;: round(qxm, 7),
                                    &#39;Age&#39;: cohort1.index, f&#39;Death {cohort1.name}&#39;: round(dx1, 2),
                                    f&#39;Death {cohort2.name}&#39;: round(dx2, 2), f&#39;Death {model.name}&#39;: round(dxm, 2),
                                    &#39;e\u20931&#39;: round(eyx, 2), &#39;e\u20932&#39;: round(eys, 2),
                                    &#39;e\u20933&#39;: round(emm, 2)})
                if death is True:

                    fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;,
                                                   f&#39;Death {cohort2.name}&#39;,
                                                   f&#39;Death {model.name}&#39;],
                                  hover_data=[f&#39;qx_{cohort1.name}&#39;, f&#39;qx_{cohort2.name}&#39;, f&#39;qx_{model.name}&#39;],
                                  title=f&#39;Death plot of {cohort1.name}, {cohort2.name} and {model.name}&#39;)
                    if qx_log is True:
                        fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;qx_{cohort1.name}&#39;,
                                                       f&#39;qx_{cohort2.name}&#39;,
                                                       f&#39;qx_{model.name}&#39;], log_y=True,
                                      hover_data=[f&#39;Death {cohort1.name}&#39;,
                                                  f&#39;Death {cohort2.name}&#39;,
                                                  f&#39;Death {model.name}&#39;],
                                      title=f&#39;Log_qx plot of {cohort1.name}, {cohort2.name} and {model.name}&#39;)

                else:
                    fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;{cohort1.name}&#39;,
                                                   f&#39;{cohort2.name}&#39;,
                                                   f&#39;{model.name}&#39;],
                                  hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;, &#39;e\u20933&#39;],
                                  title=f&#39;Survival plot of {cohort1.name}, {cohorte2.name} and {model.name}&#39;)
            fig.show()

    def p_xy(self, c1, c2, age_x: int, age_y: int, m=0,
             t: int = 1):
        &#34;&#34;&#34;
        The probability that x and y will survive t years.

        :param m: The deferred period.

        :param c1: The cohort function l(x).

        :param c2: cohort function l(y).

        :param age_x: The age of x.

        :param age_y: The age of y.

        :param t: Period until which the age should be evaluated.

        :return: The probability that x and y will survive t years.

        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal + m
        sumy = age_y + temporal + m
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        print(f&#39;The probability that both lives {age_x} and {age_y}&#39;
              f&#39; will be alive after {temporal} years is:&#39;)
        return probability

    def q_xy(self, c1, c2, age_x: int, age_y: int,
             t: int = 1):
        &#34;&#34;&#34;
        It is the probability that at least one of lives (x)
        and (y) will be dead within t years.

        :param c1: cohort function lx.

        :param c2: cohort function ly.

        :param age_x: age of x.


        :param age_y: age of y.

        :param t: Period until which the age should be evaluated.

        :return: The probability that at least one of lives (x)
                    and (y) will be dead within t years.

        &#34;&#34;&#34;
        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = (1 - probabilityx * probabilityy)
        print(f&#39;The probability that at least one of lives {age_x} and {age_y}&#39;
              f&#39; will be dead within {temporal} years is:&#39;)
        return probability

    def no_extinction(self, c1, c2, age_x: int, age_y: int,
                      t: int = 1):
        &#34;&#34;&#34;
        At least one individual will survive within t years

        :param c1: Array-like. Cohort 1.

        :param c2: Array-like. Cohort 2.

        :param age_x: Int. Age of x.

        :param age_y: Int. Age of y.

        :param t: Int. Period until which the age should be evaluate.

        :return: A probability that at least one of x and y will survive.

        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        value = probabilityy + probabilityx - probability
        print(f&#39;The probability that at least one of lives {age_x} &#39;
              f&#39;and {age_y} will be alive after {temporal} years is:&#39;)
        return value

    def dissolution_no_ex(self, c1, c2, age_x: int, age_y: int,
                          t: int = 1):
        &#34;&#34;&#34;
        The probability that exactly one life will survive(remain) within t years.

        :param c1: Array-like. The Cohort function (lx).

        :param c2: Array-like. The Cohort function l(y).

        :param age_x: Int. Age of one individual from cohort 1.

        :param age_y: Int. Age of one individual from cohort 2.

        :param t: Period until which the age should be evaluated.

        :return: The probability that exactly one individual will survive within t years.

        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        value = probabilityy + probabilityx - (2 * probability)
        print(f&#39;The probability that exactly one life will survive withing {t} years is: &#39;)
        return value

    def extinction(self, c1, c2, age_x: int, age_y: int,
                   t: int = 1):
        &#34;&#34;&#34;
        The is the probability that both lives (x) and (y) will be dead within t
        years.

        :param c1: The cohort function lx.

        :param c2: The cohort function ly.

        :param age_x: The age of x.

        :param age_y: The age of y.

        :param t: Period until which the age should  be evaluated.

        :return: The probability that both lives will die within t years.
        &#34;&#34;&#34;

        temporal = t
        sumx = age_x + temporal
        sumy = age_y + temporal
        probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
        probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
        probability = probabilityx * probabilityy
        v = probabilityy + probabilityx - probability
        value = 1 - v
        print(f&#39;The probability that both lives {age_x} and {age_y}&#39;
              f&#39; will be dead within {temporal} years is: &#39;)
        return value</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="telma.MultipleLives.dissolution_no_ex"><code class="name flex">
<span>def <span class="ident">dissolution_no_ex</span></span>(<span>self, c1, c2, age_x: int, age_y: int, t: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>The probability that exactly one life will survive(remain) within t years.</p>
<p>:param c1: Array-like. The Cohort function (lx).</p>
<p>:param c2: Array-like. The Cohort function l(y).</p>
<p>:param age_x: Int. Age of one individual from cohort 1.</p>
<p>:param age_y: Int. Age of one individual from cohort 2.</p>
<p>:param t: Period until which the age should be evaluated.</p>
<p>:return: The probability that exactly one individual will survive within t years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dissolution_no_ex(self, c1, c2, age_x: int, age_y: int,
                      t: int = 1):
    &#34;&#34;&#34;
    The probability that exactly one life will survive(remain) within t years.

    :param c1: Array-like. The Cohort function (lx).

    :param c2: Array-like. The Cohort function l(y).

    :param age_x: Int. Age of one individual from cohort 1.

    :param age_y: Int. Age of one individual from cohort 2.

    :param t: Period until which the age should be evaluated.

    :return: The probability that exactly one individual will survive within t years.

    &#34;&#34;&#34;

    temporal = t
    sumx = age_x + temporal
    sumy = age_y + temporal
    probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
    probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
    probability = probabilityx * probabilityy
    value = probabilityy + probabilityx - (2 * probability)
    print(f&#39;The probability that exactly one life will survive withing {t} years is: &#39;)
    return value</code></pre>
</details>
</dd>
<dt id="telma.MultipleLives.extinction"><code class="name flex">
<span>def <span class="ident">extinction</span></span>(<span>self, c1, c2, age_x: int, age_y: int, t: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>The is the probability that both lives (x) and (y) will be dead within t
years.</p>
<p>:param c1: The cohort function lx.</p>
<p>:param c2: The cohort function ly.</p>
<p>:param age_x: The age of x.</p>
<p>:param age_y: The age of y.</p>
<p>:param t: Period until which the age should
be evaluated.</p>
<p>:return: The probability that both lives will die within t years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extinction(self, c1, c2, age_x: int, age_y: int,
               t: int = 1):
    &#34;&#34;&#34;
    The is the probability that both lives (x) and (y) will be dead within t
    years.

    :param c1: The cohort function lx.

    :param c2: The cohort function ly.

    :param age_x: The age of x.

    :param age_y: The age of y.

    :param t: Period until which the age should  be evaluated.

    :return: The probability that both lives will die within t years.
    &#34;&#34;&#34;

    temporal = t
    sumx = age_x + temporal
    sumy = age_y + temporal
    probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
    probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
    probability = probabilityx * probabilityy
    v = probabilityy + probabilityx - probability
    value = 1 - v
    print(f&#39;The probability that both lives {age_x} and {age_y}&#39;
          f&#39; will be dead within {temporal} years is: &#39;)
    return value</code></pre>
</details>
</dd>
<dt id="telma.MultipleLives.lifeplot_2"><code class="name flex">
<span>def <span class="ident">lifeplot_2</span></span>(<span>self, cohort1, cohorte2, model=None, interactive: bool = False, qx_log: bool = False, death: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>It plots the graph of multiple cohorts interactively or static either.</p>
<p>:param cohort1: The cohort function (lx).</p>
<p>:param cohorte2: The cohort function (ly).
If len(ly)&lt;len(x) please consider passing ly as cohorte.</p>
<p>:param model: A third cohort function (lz).</p>
<p>:param qx_log: If True it displays log(qx) cohorts using plotly.</p>
<p>:param interactive: If True it displays cohorts interactively using plotly.</p>
<p>:param death: If True it displays dx cohorts using plotly.</p>
<p>:return: Living Plot, Log(qx) or dx either.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lifeplot_2(self, cohort1, cohorte2, model=None, interactive: bool = False, qx_log: bool = False,
               death: bool = False):

    &#34;&#34;&#34;
    It plots the graph of multiple cohorts interactively or static either.

    :param cohort1: The cohort function (lx).

    :param cohorte2: The cohort function (ly).
                     If len(ly)&lt;len(x) please consider passing ly as cohorte.

    :param model: A third cohort function (lz).

    :param qx_log: If True it displays log(qx) cohorts using plotly.

    :param interactive: If True it displays cohorts interactively using plotly.

    :param death: If True it displays dx cohorts using plotly.

    :return: Living Plot, Log(qx) or dx either.

    &#34;&#34;&#34;

    ful = []  ## considerar poner como cohorte2 el vector que tiene diferente longitud en interactively
    if len(cohort1) != len(cohorte2):
        for i in range(abs(len(cohort1) - len(cohorte2))):
            ful.append(0)
        cohort2 = cohorte2.append(pd.Series(ful),
                                  ignore_index=True).astype(str(cohort1.dtype))

    else:
        cohort2 = cohorte2

    #
    px1 = (cohort1.shift(-1) / cohort1).fillna(0)
    px2 = (cohort2.shift(-1) / cohort2).fillna(0)
    qx1, qx2 = 1 - px1, 1 - px2
    dx1, dx2 = qx1 * cohort1, qx2 * cohort2
    qx22 = 1 - (cohorte2.shift(-1) / cohorte2).fillna(0)
    dx22 = qx22 * cohorte2

    e1 = []
    for i in range(0, len(cohort1[:-1])):
        ley = cohort1[i]
        e1.append(sum(cohort1[i + 1:-1]) / ley)
    eyx = pd.Series(e1) + .5

    e2 = []
    for i in range(0, len(cohort2[:-1])):
        ley = cohort2[i]
        e2.append(sum(cohort2[i + 1:-1]) / ley)
    eys = pd.Series(e2) + .5

    df1 = pd.DataFrame({f&#39;{cohort1.name}&#39;: cohort1, &#39;e\u20931&#39;: round(eyx, 2),
                        f&#39;{cohort2.name}&#39;: cohort2, &#39;e\u20932&#39;: round(eys, 2),
                        &#39;Age&#39;: cohort1.index, f&#39;Death {cohort1.name}&#39;: dx1,
                        f&#39;Death {cohort2.name}&#39;: dx2})

    if not interactive:
        plt.figure(figsize=(15, 5))
        p0 = plt.subplot(1, 2, 1)
        plt.title(f&#39;Survival Plot of {cohort1.name} &#39;
                  f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
        plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
        plt.ylabel(&#39;Living people ($l_{x}$) and ($l_{y}$)&#39;, fontweight=&#39;bold&#39;)
        plt.xlim([0, 120])
        plt.plot(cohort1.index, cohort1, label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
        plt.plot(cohorte2.index, cohorte2, label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)
        # plt.legend()
        if model is not None:
            plt.plot(model.index, model, label=f&#39;{model.name}&#39;, color=&#39;red&#39;)
        plt.legend()
        p1 = plt.subplot(1, 2, 2)
        plt.title(f&#39;Death Plot of {cohort1.name} &#39;
                  f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
        plt.ylabel(&#39;Death people ($d_{x}$) and ($d_{y}$)&#39;, fontweight=&#39;bold&#39;)
        plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
        plt.xlim([0, 120])
        if qx_log is True:
            plt.title(f&#39;LogDeath Plot of {cohort1.name} &#39;
                      f&#39;and {cohorte2.name}&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;LogDeath ($d_{x}$) and ($d_{y}$)&#39;, fontweight=&#39;bold&#39;)
            plt.plot(np.log(qx1), label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
            plt.plot(np.log(qx22), label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)
        else:
            plt.plot(dx1, label=f&#39;{cohort1.name}&#39;, color=&#39;darkorange&#39;)
            plt.plot(dx22, label=f&#39;{cohorte2.name}&#39;, color=&#39;midnightblue&#39;)

        if model is not None:
            pxm = ((model / model.shift(1)).shift(-1)).fillna(0)
            qxm = 1 - pxm
            dxm = qxm * model

            if qx_log is True:
                plt.plot(np.log(qxm.replace(0, 1)), label=f&#39;{model.name}&#39;, color=&#39;red&#39;)
            else:
                plt.plot(dxm, label=f&#39;{model.name}&#39;, color=&#39;red&#39;)

        plt.legend()

        plt.show()

    else:
        import plotly.express as px
        if not death:
            fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;{cohort1.name}&#39;, f&#39;{cohort2.name}&#39;],
                          hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;],
                          title=f&#39;Survival plot of {cohort1.name} and {cohort2.name}&#39;)
        else:
            if qx_log is True:
                fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;, f&#39;Death {cohort2.name}&#39;],
                              hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;], log_y=True,
                              title=f&#39;LogDeath plot of {cohort1.name} and {cohort2.name}&#39;)
            else:
                fig = px.line(df1, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;, f&#39;Death {cohort2.name}&#39;],
                              hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;],
                              title=f&#39;Death plot of {cohort1.name} and {cohort2.name}&#39;)
        if model is not None:
            pxm = ((model / model.shift(1)).shift(-1)).fillna(0)
            qxm = 1 - pxm
            dxm = qxm * model
            em = []
            for s in range(0, len(model[:-1])):
                luc = model[s]
                em.append(sum(model[s + 1:-1]) / luc)
            emm = pd.Series(em) + .5
            df2 = pd.DataFrame({f&#39;{cohort1.name}&#39;: cohort1, f&#39;qx_{cohort1.name}&#39;: round(qx1, 7),
                                f&#39;{cohort2.name}&#39;: cohort2, f&#39;qx_{cohort2.name}&#39;: round(qx2, 7),
                                f&#39;{model.name}&#39;: model, f&#39;qx_{model.name}&#39;: round(qxm, 7),
                                &#39;Age&#39;: cohort1.index, f&#39;Death {cohort1.name}&#39;: round(dx1, 2),
                                f&#39;Death {cohort2.name}&#39;: round(dx2, 2), f&#39;Death {model.name}&#39;: round(dxm, 2),
                                &#39;e\u20931&#39;: round(eyx, 2), &#39;e\u20932&#39;: round(eys, 2),
                                &#39;e\u20933&#39;: round(emm, 2)})
            if death is True:

                fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;Death {cohort1.name}&#39;,
                                               f&#39;Death {cohort2.name}&#39;,
                                               f&#39;Death {model.name}&#39;],
                              hover_data=[f&#39;qx_{cohort1.name}&#39;, f&#39;qx_{cohort2.name}&#39;, f&#39;qx_{model.name}&#39;],
                              title=f&#39;Death plot of {cohort1.name}, {cohort2.name} and {model.name}&#39;)
                if qx_log is True:
                    fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;qx_{cohort1.name}&#39;,
                                                   f&#39;qx_{cohort2.name}&#39;,
                                                   f&#39;qx_{model.name}&#39;], log_y=True,
                                  hover_data=[f&#39;Death {cohort1.name}&#39;,
                                              f&#39;Death {cohort2.name}&#39;,
                                              f&#39;Death {model.name}&#39;],
                                  title=f&#39;Log_qx plot of {cohort1.name}, {cohort2.name} and {model.name}&#39;)

            else:
                fig = px.line(df2, x=&#39;Age&#39;, y=[f&#39;{cohort1.name}&#39;,
                                               f&#39;{cohort2.name}&#39;,
                                               f&#39;{model.name}&#39;],
                              hover_data=[&#39;e\u20931&#39;, &#39;e\u20932&#39;, &#39;e\u20933&#39;],
                              title=f&#39;Survival plot of {cohort1.name}, {cohorte2.name} and {model.name}&#39;)
        fig.show()</code></pre>
</details>
</dd>
<dt id="telma.MultipleLives.no_extinction"><code class="name flex">
<span>def <span class="ident">no_extinction</span></span>(<span>self, c1, c2, age_x: int, age_y: int, t: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>At least one individual will survive within t years</p>
<p>:param c1: Array-like. Cohort 1.</p>
<p>:param c2: Array-like. Cohort 2.</p>
<p>:param age_x: Int. Age of x.</p>
<p>:param age_y: Int. Age of y.</p>
<p>:param t: Int. Period until which the age should be evaluate.</p>
<p>:return: A probability that at least one of x and y will survive.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_extinction(self, c1, c2, age_x: int, age_y: int,
                  t: int = 1):
    &#34;&#34;&#34;
    At least one individual will survive within t years

    :param c1: Array-like. Cohort 1.

    :param c2: Array-like. Cohort 2.

    :param age_x: Int. Age of x.

    :param age_y: Int. Age of y.

    :param t: Int. Period until which the age should be evaluate.

    :return: A probability that at least one of x and y will survive.

    &#34;&#34;&#34;

    temporal = t
    sumx = age_x + temporal
    sumy = age_y + temporal
    probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
    probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
    probability = probabilityx * probabilityy
    value = probabilityy + probabilityx - probability
    print(f&#39;The probability that at least one of lives {age_x} &#39;
          f&#39;and {age_y} will be alive after {temporal} years is:&#39;)
    return value</code></pre>
</details>
</dd>
<dt id="telma.MultipleLives.p_xy"><code class="name flex">
<span>def <span class="ident">p_xy</span></span>(<span>self, c1, c2, age_x: int, age_y: int, m=0, t: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>The probability that x and y will survive t years.</p>
<p>:param m: The deferred period.</p>
<p>:param c1: The cohort function l(x).</p>
<p>:param c2: cohort function l(y).</p>
<p>:param age_x: The age of x.</p>
<p>:param age_y: The age of y.</p>
<p>:param t: Period until which the age should be evaluated.</p>
<p>:return: The probability that x and y will survive t years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def p_xy(self, c1, c2, age_x: int, age_y: int, m=0,
         t: int = 1):
    &#34;&#34;&#34;
    The probability that x and y will survive t years.

    :param m: The deferred period.

    :param c1: The cohort function l(x).

    :param c2: cohort function l(y).

    :param age_x: The age of x.

    :param age_y: The age of y.

    :param t: Period until which the age should be evaluated.

    :return: The probability that x and y will survive t years.

    &#34;&#34;&#34;

    temporal = t
    sumx = age_x + temporal + m
    sumy = age_y + temporal + m
    probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
    probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
    probability = probabilityx * probabilityy
    print(f&#39;The probability that both lives {age_x} and {age_y}&#39;
          f&#39; will be alive after {temporal} years is:&#39;)
    return probability</code></pre>
</details>
</dd>
<dt id="telma.MultipleLives.q_xy"><code class="name flex">
<span>def <span class="ident">q_xy</span></span>(<span>self, c1, c2, age_x: int, age_y: int, t: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>It is the probability that at least one of lives (x)
and (y) will be dead within t years.</p>
<p>:param c1: cohort function lx.</p>
<p>:param c2: cohort function ly.</p>
<p>:param age_x: age of x.</p>
<p>:param age_y: age of y.</p>
<p>:param t: Period until which the age should be evaluated.</p>
<p>:return: The probability that at least one of lives (x)
and (y) will be dead within t years.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def q_xy(self, c1, c2, age_x: int, age_y: int,
         t: int = 1):
    &#34;&#34;&#34;
    It is the probability that at least one of lives (x)
    and (y) will be dead within t years.

    :param c1: cohort function lx.

    :param c2: cohort function ly.

    :param age_x: age of x.


    :param age_y: age of y.

    :param t: Period until which the age should be evaluated.

    :return: The probability that at least one of lives (x)
                and (y) will be dead within t years.

    &#34;&#34;&#34;
    temporal = t
    sumx = age_x + temporal
    sumy = age_y + temporal
    probabilityx = np.roll(c1[sumx], 1) / c1[age_x]
    probabilityy = np.roll(c2[sumy], 1) / c2[age_y]
    probability = (1 - probabilityx * probabilityy)
    print(f&#39;The probability that at least one of lives {age_x} and {age_y}&#39;
          f&#39; will be dead within {temporal} years is:&#39;)
    return probability</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="telma.OneLife"><code class="flex name class">
<span>class <span class="ident">OneLife</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class refers to life actuarial basic calculation on one individual based on a given cohort (lx).</p>
<p>The life plot permits charting the cohort function in a static or dinamic mode either. (Plotly is required)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OneLife:
    &#34;&#34;&#34;

    This class refers to life actuarial basic calculation on one individual based on a given cohort (lx).

    The life plot permits charting the cohort function in a static or dinamic mode either. (Plotly is required)

    &#34;&#34;&#34;

    def lifeplot(self, cohort1, interactive: bool = False,
                 death: bool = False, qx_log: bool = False):
        &#34;&#34;&#34;
        It plots the graph of the cohort interactively or static either.
        By default is static and plots dx chart.

        :param qx_log: If True it display the log(qx) interactively.

        :param death:  If True it display the deaths interactively.

        :param cohort1: Array-like Cohort function (lx).

        :param interactive: Bool: It displays an interactive chart of
                the survival plot using Plotly.

        :return: Survival Plot of two cohort.
        &#34;&#34;&#34;

        px1 = ((cohort1 / cohort1.shift(1)).shift(-1)).fillna(0)
        qx1 = 1 - px1
        dx1 = qx1 * cohort1

        if not interactive:
            plt.figure(figsize=(15, 5))
            p0 = plt.subplot(1, 2, 1)
            plt.title(f&#39;Survival Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Living people ($l_{x}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 115])
            plt.plot(cohort1.index, cohort1, label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
            plt.legend()
            p1 = plt.subplot(1, 2, 2)
            plt.title(f&#39;Death Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
            plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
            plt.ylabel(&#39;Death people ($d_{x}$)&#39;, fontweight=&#39;bold&#39;)
            plt.xlim([0, 115])
            if qx_log:
                plt.title(f&#39;LogDeath Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
                plt.plot(np.log(qx1), label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
                plt.legend()
                plt.show()
            else:
                plt.plot(dx1, label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
                plt.legend()
                plt.show()

        else:

            import plotly.graph_objects as go
            import plotly.express as px

            if not death:
                px1 = ((cohort1 / cohort1.shift(1)).shift(-1)).fillna(0)
                qx1 = 1 - px1
                dx1 = qx1 * cohort1
                e = []
                for i in range(0, len(cohort1[:-1])):
                    lex = cohort1[i]
                    e.append(sum(cohort1[i + 1:-1]) / lex)
                exs = pd.Series(e)

                df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1, &#39;Life expectancy&#39;: round(exs, 2),
                                    &#39;Age&#39;: cohort1.index})

                fig = px.line(df1, x=&#39;Age&#39;, y=&#39;l(x)&#39;, hover_name=&#39;Life expectancy&#39;,
                              title=f&#39;Survival plot of {cohort1.name}&#39;)
                fig.update_traces(line=dict(color=&#34;crimson&#34;, width=2))
                fig.update_layout(
                    font_family=&#34;COLLEGE&#34;,
                    font_color=&#34;blue&#34;,
                    title_font_family=&#34;New Times Rowan&#34;,
                    title_font_color=&#34;red&#34;,
                    legend_title_font_color=&#34;green&#34;)

                fig.show()

            else:

                plot1 = go.Scatter(x=cohort1.index, y=qx1, mode=&#39;lines&#39;,
                                   name=f&#39;Plot of log q_x - {cohort1.name}&#39;)
                figure = go.Figure([plot1])
                figure.update_layout(title_text=f&#39;Death Plot of {cohort1.name}&#39;,
                                     xaxis_title=&#39;Age&#39;,
                                     yaxis_title=&#39;Death of people $d_{x}$&#39;,
                                     font_family=&#39;COLLEGE&#39;, font_color=&#39;black&#39;,
                                     title_font_color=&#39;red&#39;, title_font_family=&#39;New Times Rowan&#39;,
                                     legend_title_font_color=&#39;green&#39;)

                figure.show()

    def d_x(self, cohort, age: int, t: int = 1):
        &#34;&#34;&#34;
        This function computes the numbers of the between x and x+1.

        :param cohort: Array-like. The cohort function (lx).

        :param age: Int. The age of the individual.

        :param t: Int. The age from which start differencing.

        :return: The numbers of death within x and x+t.

        &#34;&#34;&#34;

        temporal = t
        sum2 = age + temporal
        dif1 = cohort[age] - cohort[sum2]
        print(f&#39;The number of deaths between {age} and {temporal} are:&#39;)
        return dif1

    def p_x(self, cohort, age: int, t: int = 1,
            i: float = .02, capital: float = 1,
            lump_sum: bool = False):
        &#34;&#34;&#34;
        p_x is the probability that (x) survives to at least age x + t.

        :param i: Float : It is the interest rate.

        :param capital: Float : It is the amount the insurer would paid.

        :param lump_sum: Boolean : If True it computes life insurance lump_sum.

        :param cohort: Array-like : It refers to the living&#39;s vector.

        :param age: Int : It refers to the actual age of the individual.

        :param t: Int : It refers to the time ahead. By default 1.

        :return: The Probability that (x) survives to at least age x + t.

        &#34;&#34;&#34;

        temporal = t
        factor = (1 + i) ** (-temporal)
        s = age + temporal
        probability = np.roll(cohort[s], 1) / cohort[age]
        value = round(factor * probability * capital, 2)
        if not lump_sum:
            print(f&#39;The probability that {age} will survive within {temporal} is:&#39;)
            return probability
        else:
            print(&#39;The life insurance to pay is:&#39;)
            return value, (probability * factor)

    def q_x(self, cohort, age: int, t: int = 1):
        &#34;&#34;&#34;
           q_{x} is the probability that (x) dies before age x + t.

        :param cohort: Array-like : It refers to the living poeple&#39;s vector.

        :param age: Int : It refers to the actual age of the individual.

        :param t: Int : It refers to the period ahead. By default 1.

        :return: The probability that (x) dies before age x + t.

        &#34;&#34;&#34;

        temporal = t
        a = age + temporal
        deaths = np.roll(cohort[age], 1) - cohort[a]
        probability = deaths / cohort[age]
        print(f&#39;The probability that {age} will die within {temporal} is:&#39;)
        return probability

    def deferred_mqx(self, cohort, age: int, m: int = 1,
                     n: int = 1):
        &#34;&#34;&#34;
        - The probability that a person aged exactly x dies between exact ages (x+n) and (x+m+n).

        :param cohort: The cohort function (lx).

        :param age:  The age of the individual.

        :param m:  Int. The deferred period. The period m is sometimes referred to as the deferred period.

        :param n: Period until which the age should be evaluated

        :return:

        &#34;&#34;&#34;

        temporal, survival = n, m
        sum1 = age + temporal
        sum2 = age + temporal + survival
        death = cohort[sum1] - cohort[sum2]
        probability = death / cohort[age]
        print(f&#39;The probability that {age} will survive within {temporal} is:&#39;)
        return probability</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="telma.OneLife.d_x"><code class="name flex">
<span>def <span class="ident">d_x</span></span>(<span>self, cohort, age: int, t: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>This function computes the numbers of the between x and x+1.</p>
<p>:param cohort: Array-like. The cohort function (lx).</p>
<p>:param age: Int. The age of the individual.</p>
<p>:param t: Int. The age from which start differencing.</p>
<p>:return: The numbers of death within x and x+t.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def d_x(self, cohort, age: int, t: int = 1):
    &#34;&#34;&#34;
    This function computes the numbers of the between x and x+1.

    :param cohort: Array-like. The cohort function (lx).

    :param age: Int. The age of the individual.

    :param t: Int. The age from which start differencing.

    :return: The numbers of death within x and x+t.

    &#34;&#34;&#34;

    temporal = t
    sum2 = age + temporal
    dif1 = cohort[age] - cohort[sum2]
    print(f&#39;The number of deaths between {age} and {temporal} are:&#39;)
    return dif1</code></pre>
</details>
</dd>
<dt id="telma.OneLife.deferred_mqx"><code class="name flex">
<span>def <span class="ident">deferred_mqx</span></span>(<span>self, cohort, age: int, m: int = 1, n: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>The probability that a person aged exactly x dies between exact ages (x+n) and (x+m+n).</li>
</ul>
<p>:param cohort: The cohort function (lx).</p>
<p>:param age:
The age of the individual.</p>
<p>:param m:
Int. The deferred period. The period m is sometimes referred to as the deferred period.</p>
<p>:param n: Period until which the age should be evaluated</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deferred_mqx(self, cohort, age: int, m: int = 1,
                 n: int = 1):
    &#34;&#34;&#34;
    - The probability that a person aged exactly x dies between exact ages (x+n) and (x+m+n).

    :param cohort: The cohort function (lx).

    :param age:  The age of the individual.

    :param m:  Int. The deferred period. The period m is sometimes referred to as the deferred period.

    :param n: Period until which the age should be evaluated

    :return:

    &#34;&#34;&#34;

    temporal, survival = n, m
    sum1 = age + temporal
    sum2 = age + temporal + survival
    death = cohort[sum1] - cohort[sum2]
    probability = death / cohort[age]
    print(f&#39;The probability that {age} will survive within {temporal} is:&#39;)
    return probability</code></pre>
</details>
</dd>
<dt id="telma.OneLife.lifeplot"><code class="name flex">
<span>def <span class="ident">lifeplot</span></span>(<span>self, cohort1, interactive: bool = False, death: bool = False, qx_log: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>It plots the graph of the cohort interactively or static either.
By default is static and plots dx chart.</p>
<p>:param qx_log: If True it display the log(qx) interactively.</p>
<p>:param death:
If True it display the deaths interactively.</p>
<p>:param cohort1: Array-like Cohort function (lx).</p>
<p>:param interactive: Bool: It displays an interactive chart of
the survival plot using Plotly.</p>
<p>:return: Survival Plot of two cohort.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lifeplot(self, cohort1, interactive: bool = False,
             death: bool = False, qx_log: bool = False):
    &#34;&#34;&#34;
    It plots the graph of the cohort interactively or static either.
    By default is static and plots dx chart.

    :param qx_log: If True it display the log(qx) interactively.

    :param death:  If True it display the deaths interactively.

    :param cohort1: Array-like Cohort function (lx).

    :param interactive: Bool: It displays an interactive chart of
            the survival plot using Plotly.

    :return: Survival Plot of two cohort.
    &#34;&#34;&#34;

    px1 = ((cohort1 / cohort1.shift(1)).shift(-1)).fillna(0)
    qx1 = 1 - px1
    dx1 = qx1 * cohort1

    if not interactive:
        plt.figure(figsize=(15, 5))
        p0 = plt.subplot(1, 2, 1)
        plt.title(f&#39;Survival Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
        plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
        plt.ylabel(&#39;Living people ($l_{x}$)&#39;, fontweight=&#39;bold&#39;)
        plt.xlim([0, 115])
        plt.plot(cohort1.index, cohort1, label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
        plt.legend()
        p1 = plt.subplot(1, 2, 2)
        plt.title(f&#39;Death Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
        plt.xlabel(&#39;Age&#39;, fontweight=&#39;bold&#39;)
        plt.ylabel(&#39;Death people ($d_{x}$)&#39;, fontweight=&#39;bold&#39;)
        plt.xlim([0, 115])
        if qx_log:
            plt.title(f&#39;LogDeath Plot of {cohort1.name}&#39;, fontweight=&#39;bold&#39;)
            plt.plot(np.log(qx1), label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
            plt.legend()
            plt.show()
        else:
            plt.plot(dx1, label=f&#39;{cohort1.name}&#39;, color=&#39;red&#39;)
            plt.legend()
            plt.show()

    else:

        import plotly.graph_objects as go
        import plotly.express as px

        if not death:
            px1 = ((cohort1 / cohort1.shift(1)).shift(-1)).fillna(0)
            qx1 = 1 - px1
            dx1 = qx1 * cohort1
            e = []
            for i in range(0, len(cohort1[:-1])):
                lex = cohort1[i]
                e.append(sum(cohort1[i + 1:-1]) / lex)
            exs = pd.Series(e)

            df1 = pd.DataFrame({&#39;l(x)&#39;: cohort1, &#39;Life expectancy&#39;: round(exs, 2),
                                &#39;Age&#39;: cohort1.index})

            fig = px.line(df1, x=&#39;Age&#39;, y=&#39;l(x)&#39;, hover_name=&#39;Life expectancy&#39;,
                          title=f&#39;Survival plot of {cohort1.name}&#39;)
            fig.update_traces(line=dict(color=&#34;crimson&#34;, width=2))
            fig.update_layout(
                font_family=&#34;COLLEGE&#34;,
                font_color=&#34;blue&#34;,
                title_font_family=&#34;New Times Rowan&#34;,
                title_font_color=&#34;red&#34;,
                legend_title_font_color=&#34;green&#34;)

            fig.show()

        else:

            plot1 = go.Scatter(x=cohort1.index, y=qx1, mode=&#39;lines&#39;,
                               name=f&#39;Plot of log q_x - {cohort1.name}&#39;)
            figure = go.Figure([plot1])
            figure.update_layout(title_text=f&#39;Death Plot of {cohort1.name}&#39;,
                                 xaxis_title=&#39;Age&#39;,
                                 yaxis_title=&#39;Death of people $d_{x}$&#39;,
                                 font_family=&#39;COLLEGE&#39;, font_color=&#39;black&#39;,
                                 title_font_color=&#39;red&#39;, title_font_family=&#39;New Times Rowan&#39;,
                                 legend_title_font_color=&#39;green&#39;)

            figure.show()</code></pre>
</details>
</dd>
<dt id="telma.OneLife.p_x"><code class="name flex">
<span>def <span class="ident">p_x</span></span>(<span>self, cohort, age: int, t: int = 1, i: float = 0.02, capital: float = 1, lump_sum: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>p_x is the probability that (x) survives to at least age x + t.</p>
<p>:param i: Float : It is the interest rate.</p>
<p>:param capital: Float : It is the amount the insurer would paid.</p>
<p>:param lump_sum: Boolean : If True it computes life insurance lump_sum.</p>
<p>:param cohort: Array-like : It refers to the living's vector.</p>
<p>:param age: Int : It refers to the actual age of the individual.</p>
<p>:param t: Int : It refers to the time ahead. By default 1.</p>
<p>:return: The Probability that (x) survives to at least age x + t.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def p_x(self, cohort, age: int, t: int = 1,
        i: float = .02, capital: float = 1,
        lump_sum: bool = False):
    &#34;&#34;&#34;
    p_x is the probability that (x) survives to at least age x + t.

    :param i: Float : It is the interest rate.

    :param capital: Float : It is the amount the insurer would paid.

    :param lump_sum: Boolean : If True it computes life insurance lump_sum.

    :param cohort: Array-like : It refers to the living&#39;s vector.

    :param age: Int : It refers to the actual age of the individual.

    :param t: Int : It refers to the time ahead. By default 1.

    :return: The Probability that (x) survives to at least age x + t.

    &#34;&#34;&#34;

    temporal = t
    factor = (1 + i) ** (-temporal)
    s = age + temporal
    probability = np.roll(cohort[s], 1) / cohort[age]
    value = round(factor * probability * capital, 2)
    if not lump_sum:
        print(f&#39;The probability that {age} will survive within {temporal} is:&#39;)
        return probability
    else:
        print(&#39;The life insurance to pay is:&#39;)
        return value, (probability * factor)</code></pre>
</details>
</dd>
<dt id="telma.OneLife.q_x"><code class="name flex">
<span>def <span class="ident">q_x</span></span>(<span>self, cohort, age: int, t: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>q_{x} is the probability that (x) dies before age x + t.</p>
<p>:param cohort: Array-like : It refers to the living poeple's vector.</p>
<p>:param age: Int : It refers to the actual age of the individual.</p>
<p>:param t: Int : It refers to the period ahead. By default 1.</p>
<p>:return: The probability that (x) dies before age x + t.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def q_x(self, cohort, age: int, t: int = 1):
    &#34;&#34;&#34;
       q_{x} is the probability that (x) dies before age x + t.

    :param cohort: Array-like : It refers to the living poeple&#39;s vector.

    :param age: Int : It refers to the actual age of the individual.

    :param t: Int : It refers to the period ahead. By default 1.

    :return: The probability that (x) dies before age x + t.

    &#34;&#34;&#34;

    temporal = t
    a = age + temporal
    deaths = np.roll(cohort[age], 1) - cohort[a]
    probability = deaths / cohort[age]
    print(f&#39;The probability that {age} will die within {temporal} is:&#39;)
    return probability</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="telma.SpainOperation"><code class="flex name class">
<span>class <span class="ident">SpainOperation</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class is particularly focus on SPANISH life actuarial calculation since annuity are calculated using the BOE.</p>
<p>Esta clase està principalmente dirigida a las operaciones actuariales del estado espanol, desde el momento en
que para llevar algunos calculo se usan como referencia las indicaciones del BOE y las PASEM/PERM.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpainOperation:

    &#34;&#34;&#34;

    This class is particularly focus on SPANISH life actuarial calculation since annuity are calculated using the BOE.

    Esta clase està principalmente dirigida a las operaciones actuariales del estado espanol, desde el momento en
     que para llevar algunos calculo se usan como referencia las indicaciones del BOE y las PASEM/PERM.

    &#34;&#34;&#34;


    def seguro_fallecimiento(self, tabla_mortalidad):

        &#34;&#34;&#34;

        Esta funciòn permite calcular un seguro de fallecimiento con misma frecuencia de variaciòn
        de cuantìa y pago. Ademas permite calcular un seguro con frecuencia de varianciòn de
        cuantìa y pago diferente. Notar que el computo requiere como parametro la tablas de mortalidad
        PASEM. Los datos para el càlculo se ingresan como input.

        :param tabla_mortalidad: Tabla de mortalidad NO GENERACIONALES PASEM

        :return: VALOR ACTUAL ACTUARIAL DEL SEGURO DE FALLECIMIENTO

        &#34;&#34;&#34;

        frac_freq = int(input(&#39;Frecuencia deseada de fraccionamiento: &#39;))
        x = int(input(&#39;Ingrese la edad del tomador del seguro: &#39;))
        m = int(input(&#39;Ingrese el periodo de diferimiento: &#39;))
        n = int(input(&#39;Temporalidad deseada: &#39;))
        if n == 109:
            n = 109 - (x + m)
        elif n != 109:
            n = n
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        taula = int(input(&#39;Tabla NO GENERACIONAL a escoger:\n&#39;
                          &#39;1: PASEM M 1° ORDEN\n&#39;
                          &#39;2: PASEM F 1° ORDERN\n&#39;
                          &#39;3: PASEM UNISEX 1° ORDEN\n&#39;
                          &#39;4: PASEM M 2° ORDEN\n&#39;
                          &#39;5: PASEM F 2° ORDEN\n&#39;
                          &#39;6: PASEM UNISEX 2° ORDEN\n&#39;))
        L = tabla_mortalidad.iloc[:, taula]
        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(2)  # Tabla creada con fraccionamiento
        interest = float(input(&#39;Tasa de interés: &#39;))  # Base técnica de la operaciòn
        t = np.arange((m * frac_freq), ((m + n) * frac_freq))  # t Periodos del sumatorio
        v = (1 + interest) ** -((t + 1) / frac_freq)
        q1 = jj[x * frac_freq + t] - jj[x * frac_freq + t + 1]
        q2 = jj[x * frac_freq]
        q = q1 / q2  # qx fallecimiento pospagable
        a1 = input(&#39;Seguro Continuo o Discreto: &#39;).lower()
        capital = input(&#39;Ingrese el tipo de Seguro:\n&#39;
                        &#39;&#34;Constante&#34;\n&#39;
                        &#39;&#34;Aritmetica&#34; o &#34;Lineal&#34;\n&#39;
                        &#39;&#34;Geometrica&#34; o &#34;Acumulativa&#34;\n&#39;).lower()
        v1 = interest / np.log(1 + interest)  # Tanto para el seguro continuo
        a2 = input(&#39;Frecuencia de variaciòn de pago y cuantìa diferentes? &#39;).lower()
        if a2 in &#39;no&#39;:
            if capital == &#39;constante&#39;:
                k1 = int(input(&#39;Cuantìa del capital: &#39;))
            elif capital in (&#39;aritmetica&#39;, &#39;lineal&#39;):
                k2 = float(input(&#39;Primer termino: &#39;))
                k2_ = float(input(&#39;Segundo termino: &#39;))
                k1 = k2 + k2_ * (t - m * frac_freq)
            elif capital in (&#39;geometrica&#39;, &#39;acumulativa&#39;):
                k3 = float(input(&#39;Primer termino: &#39;))
                k3_ = float(input(&#39;Tanto acumulativo: &#39;))
                k33 = 1 + k3_
                k1 = k3 * k33 ** (t - m * frac_freq)
            else:
                print(&#39;Error&#39;)
            if a1 in (&#39;continuo&#39;, &#39;no discreto&#39;):
                valor = sum(k1 * q * v) * v1
            elif a1 in (&#39;no continuo&#39;, &#39;discreto&#39;):
                valor = sum(k1 * q * v)
            else:
                print(&#39;Error!&#39;)
        elif a2 in &#39;si&#39;:
            a3 = int(input(&#39;Ingrese la frecuencia de variaciòn de pago (k)\n&#39;
                           &#39;Se refiere al número de términos de igual cuantía dentro de cada período de variación: &#39;))
            if capital == &#39;constante&#39;:
                k1 = int(input(&#39;Cuantìa del capital: &#39;))
            elif capital in (&#39;aritmetica&#39;, &#39;lineal&#39;):
                k2 = float(input(&#39;Primer termino: &#39;))
                k2_ = float(input(&#39;Segundo termino: &#39;))
                k1 = k2 + k2_ * np.floor((t - m * frac_freq) / a3)
            elif capital in (&#39;geometrica&#39;, &#39;acumulativa&#39;):
                k3 = float(input(&#39;Primer termino: &#39;))
                k3_ = float(input(&#39;Tanto acumulativo: &#39;))
                k33 = 1 + k3_
                k1 = k3 * k33 ** np.floor((t - m * frac_freq) / a3)
            else:
                print(&#39;Error&#39;)
            if a1 in (&#39;continuo&#39;, &#39;no discreto&#39;):
                valor = sum(k1 * q * v) * v1
            elif a1 in (&#39;no continuo&#39;, &#39;discreto&#39;):
                valor = sum(k1 * q * v)
            else:
                print(&#39;ERROR! Operaciòn no permitida.&#39;)
        else:
            print(&#39;ERROR! Operaciòn no permitida.&#39;)

        if capital == &#39;constante&#39;:

            print(&#39;=&#39; * 55)
            print(&#39;{0:5} {1:10} {2:10} {3:10}&#39;.format(&#39;t&#39;, &#39;factor v&#39;, &#39;prob. (q)&#39;, &#39;pagamentos actualizados&#39;))
            for bonita in np.arange(0, len(t)):
                print(&#39;{0:2} {1:10} {2:10} {3:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                          np.around(q[bonita], 5),
                                                          np.around(k1 * q[bonita] * v[bonita], 2)))
            print(&#39;=&#39; * 55)
            print(&#39;El Valor del seguro de fallecimento es: &#39;, round(valor, 2))
            print(&#39;=&#39; * 55)
        elif capital != &#39;constante&#39;:

            print(&#39;=&#39; * 55)
            print(&#39;{0:5} {1:10} {2:10} {3:10}&#39;.format(&#39;t&#39;, &#39;factor v&#39;, &#39;prob. (q)&#39;, &#39;pagamentos actualizados&#39;))
            for bonita in np.arange(0, len(t)):
                print(&#39;{0:2} {1:10} {2:10} {3:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                          np.around(q[bonita], 5),
                                                          np.around(k1[bonita] * q[bonita] * v[bonita], 2)))
            print(&#39;=&#39; * 55)
            print(&#39;El Valor del seguro de fallecimento es: &#39;, round(valor, 2))
            print(&#39;=&#39; * 55)  ### Valor del seguro de fallecimiento!

    def renta_constante(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                        h: int = 1, capital: float = 5000, interest: float = .02,
                        birth_year: int = 1975, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;

        Esta funciòn càlcula el valor actual actuarial de una renta de supervivencia constante.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de fraccionamiento.

        :param capital: Dinero - Capital empleado.

        :param interest: Base técnicas.

        :param birth_year: Ano de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia con capital constante.

        &#34;&#34;&#34;
        datatable = tabla_mortalidad
        frac_freq = h
        if n == 120:
            n = 120 - (x + m)
        elif n != 120:
            n = n
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(1)
        if frac_freq != 1:

            if pospagable == &#39;no&#39;:
                t = np.arange((m * h), ((m + n) * h))
                v = (1 + interest) ** -(t / h)
                p = jj[x * h + t] / jj[x * h]
            else:
                t = np.arange((m * h), ((m + n) * h))
                v = (1 + interest) ** -((t + 1) / h)
                p = jj[x * h + t + 1] / jj[x * h]
        else:
            if pospagable == &#39;no&#39;:
                t = np.arange(m, (m + n))
                v = (1 + interest) ** - t
                p = L[x + t] / L[x]
            else:
                t = np.arange(m, (m + n))
                v = (1 + interest) ** - (t + 1)
                p = L[x + t + 1] / L[x]

        renta = round(sum(capital * v * p), 2)

        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             capital,
                                                             np.around(capital * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta  # Valor actual actuarial de la renta constante

    def renta_aritmetica(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                         h: int = 1, capital: float = 500, u1: float = 50, interest: float = .02,
                         birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;

        Esta funciòn permite calcular una renta de supervivencia variable linealmente o aritmeticamente
        con frecuencia de variaciòn de pago y cuantìa igual.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param capital: Primer término de la operaciòn.

        :param u1:  Segundo termino de la operaciòn.

        :param interest:  Base Técnica.

        :param birth_year: Ano de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable linealmente.

        &#34;&#34;&#34;

        datatable = tabla_mortalidad
        frac_freq = h
        if n != 120:
            n = n
        elif n == 120:
            n = 120 - (x + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)

        if frac_freq != 1:

            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            t = np.arange((m * h), ((m + n) * h))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -(t / h)
                p = jj[x * h + t] / jj[x * h]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -((t + 1) / h)
                p = jj[x * h + t + 1] / jj[x * h]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        elif frac_freq == 1:
            t = np.arange(m, ((m + n)))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -t
                p = L[x + t] / L[x]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -(t + 1)
                p = L[x + t + 1] / L[x]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        cap = capital + u1 * (t - m * h)
        renta = round(sum(cap * v * p), 2)

        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def renta_aritmetica2(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                          h: int = 1, h1: int = 1, capital: float = 500, u1: float = 20, interest: float = .02,
                          birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;
        Esta funciòn permite calcular una renta de supervivencia variable linealmente con distinta frecuencia de
        variaciòn de pago y cuantìa.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
                    número de términos de la renta que hay en un año.
        :param capital: Primer término de la operaciòn.

        :param u1:  Segundo termino de la operaciòn.

        :param interest:  Base Técnica

        :param birth_year: Año de nacimiento del individuo

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable linealmente.

        &#34;&#34;&#34;
        datatable = tabla_mortalidad
        k = h1 / h
        frac_freq = h * k
        if n != 120:
            n = n
        elif n == 120:
            n = 120 - (x + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        if frac_freq != 1:
            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            if pospagable == &#39;no&#39;:
                t = np.arange((m * h * k), ((m + n) * h * k), dtype=&#39;int&#39;)
                v = (1 + interest) ** -(t / h1)
                p = jj[x * h1 + t] / jj[x * h1]
            else:
                t = np.arange((m * h * k), ((m + n) * h * k))
                v = (1 + interest) ** -((t + 1) / h * k)
                p = jj[x * h1 + t + 1] / jj[x * h1 * k]

        cap = capital + u1 * np.floor(t / k - m * h)

        renta = round(sum(cap * v * p), 2)
        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def renta_geometrica(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                         h: int = 1, capital: float = 500, q0: float = .015, interest: float = .02,
                         birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;
        Esta funciòn permite calcular una renta de supervivencia variable geometricamente con
        misma frecuencia de variaciò de cuantìa y pago.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param capital:  Primer término de la renta de supervivencia.

        :param q0:  Tanto acumulativo.

        :param interest:  Base técnica.

        :param birth_year: Año de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable geometricamente.

        &#34;&#34;&#34;

        datatable = tabla_mortalidad
        frac_freq = h
        if n == 120:
            n = 120 - (x + m)
        elif n != 120:
            n = n
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        # fr = np.arange(frac_freq) / frac_freq
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        if frac_freq != 1:

            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            t = np.arange((m * h), ((m + n) * h))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -(t / h)
                p = jj[x * h + t] / jj[x * h]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -((t + 1) / h)
                p = jj[x * h + t + 1] / jj[x * h]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        elif frac_freq == 1:
            t = np.arange(m, (m + n))
            if pospagable == &#39;no&#39;:
                v = (1 + interest) ** -t
                p = L[x + t] / L[x]
            elif pospagable == &#39;si&#39;:
                v = (1 + interest) ** -(t + 1)
                p = L[x + t + 1] / L[x]
            else:
                print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

        qux = (1 + q0)
        cap = capital * qux ** (t - m * h)

        renta = round(sum(cap * v * p), 2)
        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def renta_geometrica2(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                          h: int = 1, h1: int = 1, capital: float = 500, q0: float = .015, interest: float = .02,
                          birth_year: int = 1964, pospagable: str = &#39;no&#39;):
        &#34;&#34;&#34;

        Esta funciòn permite calcular una renta de supervivencia variable geometricamente con distinta frecuencia
        de variaciòn de cuantìa y pago.

        :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

        :param x:  Edad del individuo.

        :param n:  Temporalidad de la operaciòn.

        :param m:  Diferimiento de la operaciòn.

        :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                    veces que varían los términos dentro del año.

        :param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
                    número de términos de la renta que hay en un año.

        :param capital:  Primer término de la renta de supervivencia.

        :param q0:  Tanto acumulativo.

        :param interest:  Base técnica.

        :param birth_year: Año de nacimiento del individuo.

        :param pospagable: Renta pospagable o prepagable (default).

        :return: El valor actual actuarial de la renta de supervivencia variable geometricamente.

        &#34;&#34;&#34;
        datatable = tabla_mortalidad
        k = h1 / h
        frac_freq = h * k
        if n == 120:
            n = n - x
        elif n != 120:
            n = 120 - (x + m)
        else:
            print(&#39;Error! Type a new &#34;n&#34; &#39;)
        L = np.repeat(1.0, 121)
        L[0] = 1000000
        fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
        macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
        tabla = .5 * (fem + macho)
        for i in range(0, 120):
            L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
        L = np.round(L, 4)
        if frac_freq != 1:
            fr = np.arange(frac_freq) / frac_freq
            jon = np.outer(L[1:], fr)
            jon1 = np.outer(L[:-1], (1 - fr))
            jj = (jon + jon1).flatten().round(1)
            if pospagable == &#39;no&#39;:
                t = np.arange((m * h * k), ((m + n) * h * k), dtype=&#39;int&#39;)
                v = (1 + interest) ** -(t / h1)
                p = jj[x * h1 + t] / jj[x * h1]
            else:
                t = np.arange((m * h * k), (n * h * k))
                v = (1 + interest) ** -((t + 1) / h * k)
                p = jj[x * h1 + t + 1] / jj[x * h1 * k]

        qux = (1 + q0)
        cap = capital * qux ** np.floor(t / k - m * h)

        renta = round(sum(cap * v * p), 2)
        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                             np.around(p[bonita], 5),
                                                             np.around(cap[bonita], 2),
                                                             np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
        print(&#39;=&#39; * 55)

        return renta

    def vida_media_diferida(self, cohorte, x=65, m=10, kind=&#39;completa&#39;):  ## Vida media temporal |abreviada - complete

        &#34;&#34;&#34;
        Es el nùmero medio de años que por término medio vivirà un persona de edad x a partir de la edad x+t.
        Dentro de la pràctica de los seguros la vida media o vida media diferida aparece con frecuencia.
        Por ejemplo, supòngase que una persona contrata a los 30 años una plan de pensiones, a cobrar a partir
        de la jubilaciòn (65). Se desearìa conocer cùal es el nùmero de años que dicha persona vivirà tras la jubilaciòn.

        :param cohorte: La funciòn cohorte (lx). The cohort function (lx)

        :param x: La edad del individuo. The age of the individual x. By Default 65.

        :param m: The deferred period. El periodo de diferimiento. By Default 10.

        :param kind: Kind of mean life expectancy, &#34;complete&#34; or &#34;curtate&#34;. &#34;Completa&#34; o &#34;Abreviada&#34;

        :return: The deferred mean life expectancy.

        &#34;&#34;&#34;
        t = pd.Series(np.arange(m + 1, (120 - x)))
        c1 = (cohorte[x + t].sum()) / cohorte[x]
        if kind == &#39;complete&#39;:
            return c1.round(4) + (.5 * cohorte[x + m] / cohorte[x]).round(4)
        elif kind == &#39;curtate&#39;:
            return c1.round(4)
        else:
            print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)

    def vida_media_temporal(self, cohorte, x=25, n=5, kind=&#39;complete&#39;):  ## pagina 50

        &#34;&#34;&#34;
        Se trata ahora del nùmero de años que port término medio vivirà una persona de edad x en un intervalo de edades
        (x, x+t).

        :param cohorte: Funciòn cohorte (lx).

        :param x: La edad del individuo.

        :param n: La temporalidad a evaluar.

        :param kind: El tipo &#34;completo&#34; o &#34;abreviado&#34;

        :return: El valor de la vida media temporal

        &#34;&#34;&#34;
        if kind == &#39;complete&#39;:
            t = pd.Series(np.arange(1, n))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            c2 = c1 + .5 + .5 * (cohorte[x + n] / cohorte[x])
            return c2.round(7)
        elif kind == &#39;curtate&#39;:
            t = pd.Series(np.arange(1, (n + 1)))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            return c1.round(7)
        else:
            print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)

    def vida_media_mixta(self, cohorte, x=25, m=10, n=5, kind=&#39;complete&#39;):  ## Pagina 51 Estadistica actuarial vida

        &#34;&#34;&#34;
        Se trata ahora del nùmero de años que vivirà una persona de edad x en un intervalo de edades (x+m, x+m+n).

        :param cohorte: La funcin cohorte (lx). The cohort function (lx)

        :param x: La edad del individuo. The age of the individual x

        :param m: The deferred period. El periodo de diferimiento.

        :param n: El periodo hasta la evaluaciòn. The period until which the age should be evaluated

        :param kind: El tipo

        :return: La vida media mixta.

        &#34;&#34;&#34;
        if kind == &#39;complete&#39;:
            t = pd.Series(np.arange((m + 1), (m + n)))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            c2 = .5 * (cohorte[x + m] / cohorte[x]) + .5 * (cohorte[x + m + n] / cohorte[x])
            return (c2 + c1).round(7)
        elif kind == &#39;curtate&#39;:
            t = pd.Series(np.arange((m + 1), (m + n + 1)))
            c1 = (cohorte[x + t].sum()) / cohorte[x]
            return c1.round(7)
        else:
            print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="telma.SpainOperation.renta_aritmetica"><code class="name flex">
<span>def <span class="ident">renta_aritmetica</span></span>(<span>self, tabla_mortalidad, x: int, n: int = 120, m: int = 0, h: int = 1, capital: float = 500, u1: float = 50, interest: float = 0.02, birth_year: int = 1964, pospagable: str = 'no')</span>
</code></dt>
<dd>
<div class="desc"><p>Esta funciòn permite calcular una renta de supervivencia variable linealmente o aritmeticamente
con frecuencia de variaciòn de pago y cuantìa igual.</p>
<p>:param tabla_mortalidad:
Tabla de mortalidad generacionales PERM.</p>
<p>:param x:
Edad del individuo.</p>
<p>:param n:
Temporalidad de la operaciòn.</p>
<p>:param m:
Diferimiento de la operaciòn.</p>
<p>:param h:
Frecuencia de variación de los términos dentro del año. Proporciona el número de
veces que varían los términos dentro del año.</p>
<p>:param capital: Primer término de la operaciòn.</p>
<p>:param u1:
Segundo termino de la operaciòn.</p>
<p>:param interest:
Base Técnica.</p>
<p>:param birth_year: Ano de nacimiento del individuo.</p>
<p>:param pospagable: Renta pospagable o prepagable (default).</p>
<p>:return: El valor actual actuarial de la renta de supervivencia variable linealmente.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renta_aritmetica(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                     h: int = 1, capital: float = 500, u1: float = 50, interest: float = .02,
                     birth_year: int = 1964, pospagable: str = &#39;no&#39;):
    &#34;&#34;&#34;

    Esta funciòn permite calcular una renta de supervivencia variable linealmente o aritmeticamente
    con frecuencia de variaciòn de pago y cuantìa igual.

    :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

    :param x:  Edad del individuo.

    :param n:  Temporalidad de la operaciòn.

    :param m:  Diferimiento de la operaciòn.

    :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                veces que varían los términos dentro del año.

    :param capital: Primer término de la operaciòn.

    :param u1:  Segundo termino de la operaciòn.

    :param interest:  Base Técnica.

    :param birth_year: Ano de nacimiento del individuo.

    :param pospagable: Renta pospagable o prepagable (default).

    :return: El valor actual actuarial de la renta de supervivencia variable linealmente.

    &#34;&#34;&#34;

    datatable = tabla_mortalidad
    frac_freq = h
    if n != 120:
        n = n
    elif n == 120:
        n = 120 - (x + m)
    else:
        print(&#39;Error! Type a new &#34;n&#34; &#39;)
    L = np.repeat(1.0, 121)
    L[0] = 1000000
    fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
    macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
    tabla = .5 * (fem + macho)
    for i in range(0, 120):
        L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
    L = np.round(L, 4)

    if frac_freq != 1:

        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(1)
        t = np.arange((m * h), ((m + n) * h))
        if pospagable == &#39;no&#39;:
            v = (1 + interest) ** -(t / h)
            p = jj[x * h + t] / jj[x * h]
        elif pospagable == &#39;si&#39;:
            v = (1 + interest) ** -((t + 1) / h)
            p = jj[x * h + t + 1] / jj[x * h]
        else:
            print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

    elif frac_freq == 1:
        t = np.arange(m, ((m + n)))
        if pospagable == &#39;no&#39;:
            v = (1 + interest) ** -t
            p = L[x + t] / L[x]
        elif pospagable == &#39;si&#39;:
            v = (1 + interest) ** -(t + 1)
            p = L[x + t + 1] / L[x]
        else:
            print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

    cap = capital + u1 * (t - m * h)
    renta = round(sum(cap * v * p), 2)

    print(&#39;=&#39; * 55)
    print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
    for bonita in np.arange(0, len(t)):
        print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                         np.around(p[bonita], 5),
                                                         np.around(cap[bonita], 2),
                                                         np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
    print(&#39;=&#39; * 55)
    print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
    print(&#39;=&#39; * 55)

    return renta</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.renta_aritmetica2"><code class="name flex">
<span>def <span class="ident">renta_aritmetica2</span></span>(<span>self, tabla_mortalidad, x: int, n: int = 120, m: int = 0, h: int = 1, h1: int = 1, capital: float = 500, u1: float = 20, interest: float = 0.02, birth_year: int = 1964, pospagable: str = 'no')</span>
</code></dt>
<dd>
<div class="desc"><p>Esta funciòn permite calcular una renta de supervivencia variable linealmente con distinta frecuencia de
variaciòn de pago y cuantìa.</p>
<p>:param tabla_mortalidad:
Tabla de mortalidad generacionales PERM.</p>
<p>:param x:
Edad del individuo.</p>
<p>:param n:
Temporalidad de la operaciòn.</p>
<p>:param m:
Diferimiento de la operaciòn.</p>
<p>:param h:
Frecuencia de variación de los términos dentro del año. Proporciona el número de
veces que varían los términos dentro del año.</p>
<p>:param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
número de términos de la renta que hay en un año.
:param capital: Primer término de la operaciòn.</p>
<p>:param u1:
Segundo termino de la operaciòn.</p>
<p>:param interest:
Base Técnica</p>
<p>:param birth_year: Año de nacimiento del individuo</p>
<p>:param pospagable: Renta pospagable o prepagable (default).</p>
<p>:return: El valor actual actuarial de la renta de supervivencia variable linealmente.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renta_aritmetica2(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                      h: int = 1, h1: int = 1, capital: float = 500, u1: float = 20, interest: float = .02,
                      birth_year: int = 1964, pospagable: str = &#39;no&#39;):
    &#34;&#34;&#34;
    Esta funciòn permite calcular una renta de supervivencia variable linealmente con distinta frecuencia de
    variaciòn de pago y cuantìa.

    :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

    :param x:  Edad del individuo.

    :param n:  Temporalidad de la operaciòn.

    :param m:  Diferimiento de la operaciòn.

    :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                veces que varían los términos dentro del año.

    :param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
                número de términos de la renta que hay en un año.
    :param capital: Primer término de la operaciòn.

    :param u1:  Segundo termino de la operaciòn.

    :param interest:  Base Técnica

    :param birth_year: Año de nacimiento del individuo

    :param pospagable: Renta pospagable o prepagable (default).

    :return: El valor actual actuarial de la renta de supervivencia variable linealmente.

    &#34;&#34;&#34;
    datatable = tabla_mortalidad
    k = h1 / h
    frac_freq = h * k
    if n != 120:
        n = n
    elif n == 120:
        n = 120 - (x + m)
    else:
        print(&#39;Error! Type a new &#34;n&#34; &#39;)
    L = np.repeat(1.0, 121)
    L[0] = 1000000
    fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
    macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
    tabla = .5 * (fem + macho)
    for i in range(0, 120):
        L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
    L = np.round(L, 4)
    if frac_freq != 1:
        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(1)
        if pospagable == &#39;no&#39;:
            t = np.arange((m * h * k), ((m + n) * h * k), dtype=&#39;int&#39;)
            v = (1 + interest) ** -(t / h1)
            p = jj[x * h1 + t] / jj[x * h1]
        else:
            t = np.arange((m * h * k), ((m + n) * h * k))
            v = (1 + interest) ** -((t + 1) / h * k)
            p = jj[x * h1 + t + 1] / jj[x * h1 * k]

    cap = capital + u1 * np.floor(t / k - m * h)

    renta = round(sum(cap * v * p), 2)
    print(&#39;=&#39; * 55)
    print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
    for bonita in np.arange(0, len(t)):
        print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                         np.around(p[bonita], 5),
                                                         np.around(cap[bonita], 2),
                                                         np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
    print(&#39;=&#39; * 55)
    print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
    print(&#39;=&#39; * 55)

    return renta</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.renta_constante"><code class="name flex">
<span>def <span class="ident">renta_constante</span></span>(<span>self, tabla_mortalidad, x: int, n: int = 120, m: int = 0, h: int = 1, capital: float = 5000, interest: float = 0.02, birth_year: int = 1975, pospagable: str = 'no')</span>
</code></dt>
<dd>
<div class="desc"><p>Esta funciòn càlcula el valor actual actuarial de una renta de supervivencia constante.</p>
<p>:param tabla_mortalidad:
Tabla de mortalidad generacionales PERM.</p>
<p>:param x:
Edad del individuo.</p>
<p>:param n:
Temporalidad de la operaciòn.</p>
<p>:param m:
Diferimiento de la operaciòn.</p>
<p>:param h:
Frecuencia de fraccionamiento.</p>
<p>:param capital: Dinero - Capital empleado.</p>
<p>:param interest: Base técnicas.</p>
<p>:param birth_year: Ano de nacimiento del individuo.</p>
<p>:param pospagable: Renta pospagable o prepagable (default).</p>
<p>:return: El valor actual actuarial de la renta de supervivencia con capital constante.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renta_constante(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                    h: int = 1, capital: float = 5000, interest: float = .02,
                    birth_year: int = 1975, pospagable: str = &#39;no&#39;):
    &#34;&#34;&#34;

    Esta funciòn càlcula el valor actual actuarial de una renta de supervivencia constante.

    :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

    :param x:  Edad del individuo.

    :param n:  Temporalidad de la operaciòn.

    :param m:  Diferimiento de la operaciòn.

    :param h:  Frecuencia de fraccionamiento.

    :param capital: Dinero - Capital empleado.

    :param interest: Base técnicas.

    :param birth_year: Ano de nacimiento del individuo.

    :param pospagable: Renta pospagable o prepagable (default).

    :return: El valor actual actuarial de la renta de supervivencia con capital constante.

    &#34;&#34;&#34;
    datatable = tabla_mortalidad
    frac_freq = h
    if n == 120:
        n = 120 - (x + m)
    elif n != 120:
        n = n
    else:
        print(&#39;Error! Type a new &#34;n&#34; &#39;)
    L = np.repeat(1.0, 121)
    L[0] = 1000000
    fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
    macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
    tabla = .5 * (fem + macho)
    for i in range(0, 120):
        L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
    L = np.round(L, 4)
    fr = np.arange(frac_freq) / frac_freq
    jon = np.outer(L[1:], fr)
    jon1 = np.outer(L[:-1], (1 - fr))
    jj = (jon + jon1).flatten().round(1)
    if frac_freq != 1:

        if pospagable == &#39;no&#39;:
            t = np.arange((m * h), ((m + n) * h))
            v = (1 + interest) ** -(t / h)
            p = jj[x * h + t] / jj[x * h]
        else:
            t = np.arange((m * h), ((m + n) * h))
            v = (1 + interest) ** -((t + 1) / h)
            p = jj[x * h + t + 1] / jj[x * h]
    else:
        if pospagable == &#39;no&#39;:
            t = np.arange(m, (m + n))
            v = (1 + interest) ** - t
            p = L[x + t] / L[x]
        else:
            t = np.arange(m, (m + n))
            v = (1 + interest) ** - (t + 1)
            p = L[x + t + 1] / L[x]

    renta = round(sum(capital * v * p), 2)

    print(&#39;=&#39; * 55)
    print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
    for bonita in np.arange(0, len(t)):
        print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                         np.around(p[bonita], 5),
                                                         capital,
                                                         np.around(capital * p[bonita] * v[bonita], 2)))
    print(&#39;=&#39; * 55)
    print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
    print(&#39;=&#39; * 55)

    return renta  # Valor actual actuarial de la renta constante</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.renta_geometrica"><code class="name flex">
<span>def <span class="ident">renta_geometrica</span></span>(<span>self, tabla_mortalidad, x: int, n: int = 120, m: int = 0, h: int = 1, capital: float = 500, q0: float = 0.015, interest: float = 0.02, birth_year: int = 1964, pospagable: str = 'no')</span>
</code></dt>
<dd>
<div class="desc"><p>Esta funciòn permite calcular una renta de supervivencia variable geometricamente con
misma frecuencia de variaciò de cuantìa y pago.</p>
<p>:param tabla_mortalidad:
Tabla de mortalidad generacionales PERM.</p>
<p>:param x:
Edad del individuo.</p>
<p>:param n:
Temporalidad de la operaciòn.</p>
<p>:param m:
Diferimiento de la operaciòn.</p>
<p>:param h:
Frecuencia de variación de los términos dentro del año. Proporciona el número de
veces que varían los términos dentro del año.</p>
<p>:param capital:
Primer término de la renta de supervivencia.</p>
<p>:param q0:
Tanto acumulativo.</p>
<p>:param interest:
Base técnica.</p>
<p>:param birth_year: Año de nacimiento del individuo.</p>
<p>:param pospagable: Renta pospagable o prepagable (default).</p>
<p>:return: El valor actual actuarial de la renta de supervivencia variable geometricamente.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renta_geometrica(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                     h: int = 1, capital: float = 500, q0: float = .015, interest: float = .02,
                     birth_year: int = 1964, pospagable: str = &#39;no&#39;):
    &#34;&#34;&#34;
    Esta funciòn permite calcular una renta de supervivencia variable geometricamente con
    misma frecuencia de variaciò de cuantìa y pago.

    :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

    :param x:  Edad del individuo.

    :param n:  Temporalidad de la operaciòn.

    :param m:  Diferimiento de la operaciòn.

    :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                veces que varían los términos dentro del año.

    :param capital:  Primer término de la renta de supervivencia.

    :param q0:  Tanto acumulativo.

    :param interest:  Base técnica.

    :param birth_year: Año de nacimiento del individuo.

    :param pospagable: Renta pospagable o prepagable (default).

    :return: El valor actual actuarial de la renta de supervivencia variable geometricamente.

    &#34;&#34;&#34;

    datatable = tabla_mortalidad
    frac_freq = h
    if n == 120:
        n = 120 - (x + m)
    elif n != 120:
        n = n
    else:
        print(&#39;Error! Type a new &#34;n&#34; &#39;)
    L = np.repeat(1.0, 121)
    L[0] = 1000000
    # fr = np.arange(frac_freq) / frac_freq
    fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
    macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
    tabla = .5 * (fem + macho)
    for i in range(0, 120):
        L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
    L = np.round(L, 4)
    if frac_freq != 1:

        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(1)
        t = np.arange((m * h), ((m + n) * h))
        if pospagable == &#39;no&#39;:
            v = (1 + interest) ** -(t / h)
            p = jj[x * h + t] / jj[x * h]
        elif pospagable == &#39;si&#39;:
            v = (1 + interest) ** -((t + 1) / h)
            p = jj[x * h + t + 1] / jj[x * h]
        else:
            print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

    elif frac_freq == 1:
        t = np.arange(m, (m + n))
        if pospagable == &#39;no&#39;:
            v = (1 + interest) ** -t
            p = L[x + t] / L[x]
        elif pospagable == &#39;si&#39;:
            v = (1 + interest) ** -(t + 1)
            p = L[x + t + 1] / L[x]
        else:
            print(&#39;Pospagable acepta solamente &#34;no&#34; y &#34;si&#34;&#39;)

    qux = (1 + q0)
    cap = capital * qux ** (t - m * h)

    renta = round(sum(cap * v * p), 2)
    print(&#39;=&#39; * 55)
    print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
    for bonita in np.arange(0, len(t)):
        print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                         np.around(p[bonita], 5),
                                                         np.around(cap[bonita], 2),
                                                         np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
    print(&#39;=&#39; * 55)
    print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
    print(&#39;=&#39; * 55)

    return renta</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.renta_geometrica2"><code class="name flex">
<span>def <span class="ident">renta_geometrica2</span></span>(<span>self, tabla_mortalidad, x: int, n: int = 120, m: int = 0, h: int = 1, h1: int = 1, capital: float = 500, q0: float = 0.015, interest: float = 0.02, birth_year: int = 1964, pospagable: str = 'no')</span>
</code></dt>
<dd>
<div class="desc"><p>Esta funciòn permite calcular una renta de supervivencia variable geometricamente con distinta frecuencia
de variaciòn de cuantìa y pago.</p>
<p>:param tabla_mortalidad:
Tabla de mortalidad generacionales PERM.</p>
<p>:param x:
Edad del individuo.</p>
<p>:param n:
Temporalidad de la operaciòn.</p>
<p>:param m:
Diferimiento de la operaciòn.</p>
<p>:param h:
Frecuencia de variación de los términos dentro del año. Proporciona el número de
veces que varían los términos dentro del año.</p>
<p>:param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
número de términos de la renta que hay en un año.</p>
<p>:param capital:
Primer término de la renta de supervivencia.</p>
<p>:param q0:
Tanto acumulativo.</p>
<p>:param interest:
Base técnica.</p>
<p>:param birth_year: Año de nacimiento del individuo.</p>
<p>:param pospagable: Renta pospagable o prepagable (default).</p>
<p>:return: El valor actual actuarial de la renta de supervivencia variable geometricamente.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renta_geometrica2(self, tabla_mortalidad, x: int, n: int = 120, m: int = 0,
                      h: int = 1, h1: int = 1, capital: float = 500, q0: float = .015, interest: float = .02,
                      birth_year: int = 1964, pospagable: str = &#39;no&#39;):
    &#34;&#34;&#34;

    Esta funciòn permite calcular una renta de supervivencia variable geometricamente con distinta frecuencia
    de variaciòn de cuantìa y pago.

    :param tabla_mortalidad:  Tabla de mortalidad generacionales PERM.

    :param x:  Edad del individuo.

    :param n:  Temporalidad de la operaciòn.

    :param m:  Diferimiento de la operaciòn.

    :param h:  Frecuencia de variación de los términos dentro del año. Proporciona el número de
                veces que varían los términos dentro del año.

    :param h1: Frecuencia de pago de los términos de la renta dentro del año. Proporciona el
                número de términos de la renta que hay en un año.

    :param capital:  Primer término de la renta de supervivencia.

    :param q0:  Tanto acumulativo.

    :param interest:  Base técnica.

    :param birth_year: Año de nacimiento del individuo.

    :param pospagable: Renta pospagable o prepagable (default).

    :return: El valor actual actuarial de la renta de supervivencia variable geometricamente.

    &#34;&#34;&#34;
    datatable = tabla_mortalidad
    k = h1 / h
    frac_freq = h * k
    if n == 120:
        n = n - x
    elif n != 120:
        n = 120 - (x + m)
    else:
        print(&#39;Error! Type a new &#34;n&#34; &#39;)
    L = np.repeat(1.0, 121)
    L[0] = 1000000
    fem = datatable.iloc[:, 1] * np.exp(-datatable.iloc[:, 2] * (birth_year + np.arange(0, 121) - 2012))
    macho = datatable.iloc[:, 3] * np.exp(-datatable.iloc[:, 4] * (birth_year + np.arange(0, 121) - 2012))
    tabla = .5 * (fem + macho)
    for i in range(0, 120):
        L[i + 1] = L[i] * (1 - (tabla[i] / 1000))
    L = np.round(L, 4)
    if frac_freq != 1:
        fr = np.arange(frac_freq) / frac_freq
        jon = np.outer(L[1:], fr)
        jon1 = np.outer(L[:-1], (1 - fr))
        jj = (jon + jon1).flatten().round(1)
        if pospagable == &#39;no&#39;:
            t = np.arange((m * h * k), ((m + n) * h * k), dtype=&#39;int&#39;)
            v = (1 + interest) ** -(t / h1)
            p = jj[x * h1 + t] / jj[x * h1]
        else:
            t = np.arange((m * h * k), (n * h * k))
            v = (1 + interest) ** -((t + 1) / h * k)
            p = jj[x * h1 + t + 1] / jj[x * h1 * k]

    qux = (1 + q0)
    cap = capital * qux ** np.floor(t / k - m * h)

    renta = round(sum(cap * v * p), 2)
    print(&#39;=&#39; * 55)
    print(&#39;{0:5} {1:10} {2:10} {3:10} {4:10}&#39;.format(&#39;t&#39;, &#39;Factor v&#39;, &#39;prob. (q)&#39;, &#39;Pagamentos&#39;, &#39;Cuantias&#39;))
    for bonita in np.arange(0, len(t)):
        print(&#39;{0:2} {1:10} {2:10} {3:10} {4:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                         np.around(p[bonita], 5),
                                                         np.around(cap[bonita], 2),
                                                         np.around(cap[bonita] * p[bonita] * v[bonita], 2)))
    print(&#39;=&#39; * 55)
    print(&#39;El valor de la renta de supervivencia es: &#39;, round(renta, 2))
    print(&#39;=&#39; * 55)

    return renta</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.seguro_fallecimiento"><code class="name flex">
<span>def <span class="ident">seguro_fallecimiento</span></span>(<span>self, tabla_mortalidad)</span>
</code></dt>
<dd>
<div class="desc"><p>Esta funciòn permite calcular un seguro de fallecimiento con misma frecuencia de variaciòn
de cuantìa y pago. Ademas permite calcular un seguro con frecuencia de varianciòn de
cuantìa y pago diferente. Notar que el computo requiere como parametro la tablas de mortalidad
PASEM. Los datos para el càlculo se ingresan como input.</p>
<p>:param tabla_mortalidad: Tabla de mortalidad NO GENERACIONALES PASEM</p>
<p>:return: VALOR ACTUAL ACTUARIAL DEL SEGURO DE FALLECIMIENTO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seguro_fallecimiento(self, tabla_mortalidad):

    &#34;&#34;&#34;

    Esta funciòn permite calcular un seguro de fallecimiento con misma frecuencia de variaciòn
    de cuantìa y pago. Ademas permite calcular un seguro con frecuencia de varianciòn de
    cuantìa y pago diferente. Notar que el computo requiere como parametro la tablas de mortalidad
    PASEM. Los datos para el càlculo se ingresan como input.

    :param tabla_mortalidad: Tabla de mortalidad NO GENERACIONALES PASEM

    :return: VALOR ACTUAL ACTUARIAL DEL SEGURO DE FALLECIMIENTO

    &#34;&#34;&#34;

    frac_freq = int(input(&#39;Frecuencia deseada de fraccionamiento: &#39;))
    x = int(input(&#39;Ingrese la edad del tomador del seguro: &#39;))
    m = int(input(&#39;Ingrese el periodo de diferimiento: &#39;))
    n = int(input(&#39;Temporalidad deseada: &#39;))
    if n == 109:
        n = 109 - (x + m)
    elif n != 109:
        n = n
    else:
        print(&#39;Error! Type a new &#34;n&#34; &#39;)
    taula = int(input(&#39;Tabla NO GENERACIONAL a escoger:\n&#39;
                      &#39;1: PASEM M 1° ORDEN\n&#39;
                      &#39;2: PASEM F 1° ORDERN\n&#39;
                      &#39;3: PASEM UNISEX 1° ORDEN\n&#39;
                      &#39;4: PASEM M 2° ORDEN\n&#39;
                      &#39;5: PASEM F 2° ORDEN\n&#39;
                      &#39;6: PASEM UNISEX 2° ORDEN\n&#39;))
    L = tabla_mortalidad.iloc[:, taula]
    fr = np.arange(frac_freq) / frac_freq
    jon = np.outer(L[1:], fr)
    jon1 = np.outer(L[:-1], (1 - fr))
    jj = (jon + jon1).flatten().round(2)  # Tabla creada con fraccionamiento
    interest = float(input(&#39;Tasa de interés: &#39;))  # Base técnica de la operaciòn
    t = np.arange((m * frac_freq), ((m + n) * frac_freq))  # t Periodos del sumatorio
    v = (1 + interest) ** -((t + 1) / frac_freq)
    q1 = jj[x * frac_freq + t] - jj[x * frac_freq + t + 1]
    q2 = jj[x * frac_freq]
    q = q1 / q2  # qx fallecimiento pospagable
    a1 = input(&#39;Seguro Continuo o Discreto: &#39;).lower()
    capital = input(&#39;Ingrese el tipo de Seguro:\n&#39;
                    &#39;&#34;Constante&#34;\n&#39;
                    &#39;&#34;Aritmetica&#34; o &#34;Lineal&#34;\n&#39;
                    &#39;&#34;Geometrica&#34; o &#34;Acumulativa&#34;\n&#39;).lower()
    v1 = interest / np.log(1 + interest)  # Tanto para el seguro continuo
    a2 = input(&#39;Frecuencia de variaciòn de pago y cuantìa diferentes? &#39;).lower()
    if a2 in &#39;no&#39;:
        if capital == &#39;constante&#39;:
            k1 = int(input(&#39;Cuantìa del capital: &#39;))
        elif capital in (&#39;aritmetica&#39;, &#39;lineal&#39;):
            k2 = float(input(&#39;Primer termino: &#39;))
            k2_ = float(input(&#39;Segundo termino: &#39;))
            k1 = k2 + k2_ * (t - m * frac_freq)
        elif capital in (&#39;geometrica&#39;, &#39;acumulativa&#39;):
            k3 = float(input(&#39;Primer termino: &#39;))
            k3_ = float(input(&#39;Tanto acumulativo: &#39;))
            k33 = 1 + k3_
            k1 = k3 * k33 ** (t - m * frac_freq)
        else:
            print(&#39;Error&#39;)
        if a1 in (&#39;continuo&#39;, &#39;no discreto&#39;):
            valor = sum(k1 * q * v) * v1
        elif a1 in (&#39;no continuo&#39;, &#39;discreto&#39;):
            valor = sum(k1 * q * v)
        else:
            print(&#39;Error!&#39;)
    elif a2 in &#39;si&#39;:
        a3 = int(input(&#39;Ingrese la frecuencia de variaciòn de pago (k)\n&#39;
                       &#39;Se refiere al número de términos de igual cuantía dentro de cada período de variación: &#39;))
        if capital == &#39;constante&#39;:
            k1 = int(input(&#39;Cuantìa del capital: &#39;))
        elif capital in (&#39;aritmetica&#39;, &#39;lineal&#39;):
            k2 = float(input(&#39;Primer termino: &#39;))
            k2_ = float(input(&#39;Segundo termino: &#39;))
            k1 = k2 + k2_ * np.floor((t - m * frac_freq) / a3)
        elif capital in (&#39;geometrica&#39;, &#39;acumulativa&#39;):
            k3 = float(input(&#39;Primer termino: &#39;))
            k3_ = float(input(&#39;Tanto acumulativo: &#39;))
            k33 = 1 + k3_
            k1 = k3 * k33 ** np.floor((t - m * frac_freq) / a3)
        else:
            print(&#39;Error&#39;)
        if a1 in (&#39;continuo&#39;, &#39;no discreto&#39;):
            valor = sum(k1 * q * v) * v1
        elif a1 in (&#39;no continuo&#39;, &#39;discreto&#39;):
            valor = sum(k1 * q * v)
        else:
            print(&#39;ERROR! Operaciòn no permitida.&#39;)
    else:
        print(&#39;ERROR! Operaciòn no permitida.&#39;)

    if capital == &#39;constante&#39;:

        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10}&#39;.format(&#39;t&#39;, &#39;factor v&#39;, &#39;prob. (q)&#39;, &#39;pagamentos actualizados&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                      np.around(q[bonita], 5),
                                                      np.around(k1 * q[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El Valor del seguro de fallecimento es: &#39;, round(valor, 2))
        print(&#39;=&#39; * 55)
    elif capital != &#39;constante&#39;:

        print(&#39;=&#39; * 55)
        print(&#39;{0:5} {1:10} {2:10} {3:10}&#39;.format(&#39;t&#39;, &#39;factor v&#39;, &#39;prob. (q)&#39;, &#39;pagamentos actualizados&#39;))
        for bonita in np.arange(0, len(t)):
            print(&#39;{0:2} {1:10} {2:10} {3:10}&#39;.format(bonita, (np.around(v[bonita], 5)),
                                                      np.around(q[bonita], 5),
                                                      np.around(k1[bonita] * q[bonita] * v[bonita], 2)))
        print(&#39;=&#39; * 55)
        print(&#39;El Valor del seguro de fallecimento es: &#39;, round(valor, 2))
        print(&#39;=&#39; * 55)  ### Valor del seguro de fallecimiento!</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.vida_media_diferida"><code class="name flex">
<span>def <span class="ident">vida_media_diferida</span></span>(<span>self, cohorte, x=65, m=10, kind='completa')</span>
</code></dt>
<dd>
<div class="desc"><p>Es el nùmero medio de años que por término medio vivirà un persona de edad x a partir de la edad x+t.
Dentro de la pràctica de los seguros la vida media o vida media diferida aparece con frecuencia.
Por ejemplo, supòngase que una persona contrata a los 30 años una plan de pensiones, a cobrar a partir
de la jubilaciòn (65). Se desearìa conocer cùal es el nùmero de años que dicha persona vivirà tras la jubilaciòn.</p>
<p>:param cohorte: La funciòn cohorte (lx). The cohort function (lx)</p>
<p>:param x: La edad del individuo. The age of the individual x. By Default 65.</p>
<p>:param m: The deferred period. El periodo de diferimiento. By Default 10.</p>
<p>:param kind: Kind of mean life expectancy, "complete" or "curtate". "Completa" o "Abreviada"</p>
<p>:return: The deferred mean life expectancy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vida_media_diferida(self, cohorte, x=65, m=10, kind=&#39;completa&#39;):  ## Vida media temporal |abreviada - complete

    &#34;&#34;&#34;
    Es el nùmero medio de años que por término medio vivirà un persona de edad x a partir de la edad x+t.
    Dentro de la pràctica de los seguros la vida media o vida media diferida aparece con frecuencia.
    Por ejemplo, supòngase que una persona contrata a los 30 años una plan de pensiones, a cobrar a partir
    de la jubilaciòn (65). Se desearìa conocer cùal es el nùmero de años que dicha persona vivirà tras la jubilaciòn.

    :param cohorte: La funciòn cohorte (lx). The cohort function (lx)

    :param x: La edad del individuo. The age of the individual x. By Default 65.

    :param m: The deferred period. El periodo de diferimiento. By Default 10.

    :param kind: Kind of mean life expectancy, &#34;complete&#34; or &#34;curtate&#34;. &#34;Completa&#34; o &#34;Abreviada&#34;

    :return: The deferred mean life expectancy.

    &#34;&#34;&#34;
    t = pd.Series(np.arange(m + 1, (120 - x)))
    c1 = (cohorte[x + t].sum()) / cohorte[x]
    if kind == &#39;complete&#39;:
        return c1.round(4) + (.5 * cohorte[x + m] / cohorte[x]).round(4)
    elif kind == &#39;curtate&#39;:
        return c1.round(4)
    else:
        print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.vida_media_mixta"><code class="name flex">
<span>def <span class="ident">vida_media_mixta</span></span>(<span>self, cohorte, x=25, m=10, n=5, kind='complete')</span>
</code></dt>
<dd>
<div class="desc"><p>Se trata ahora del nùmero de años que vivirà una persona de edad x en un intervalo de edades (x+m, x+m+n).</p>
<p>:param cohorte: La funcin cohorte (lx). The cohort function (lx)</p>
<p>:param x: La edad del individuo. The age of the individual x</p>
<p>:param m: The deferred period. El periodo de diferimiento.</p>
<p>:param n: El periodo hasta la evaluaciòn. The period until which the age should be evaluated</p>
<p>:param kind: El tipo</p>
<p>:return: La vida media mixta.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vida_media_mixta(self, cohorte, x=25, m=10, n=5, kind=&#39;complete&#39;):  ## Pagina 51 Estadistica actuarial vida

    &#34;&#34;&#34;
    Se trata ahora del nùmero de años que vivirà una persona de edad x en un intervalo de edades (x+m, x+m+n).

    :param cohorte: La funcin cohorte (lx). The cohort function (lx)

    :param x: La edad del individuo. The age of the individual x

    :param m: The deferred period. El periodo de diferimiento.

    :param n: El periodo hasta la evaluaciòn. The period until which the age should be evaluated

    :param kind: El tipo

    :return: La vida media mixta.

    &#34;&#34;&#34;
    if kind == &#39;complete&#39;:
        t = pd.Series(np.arange((m + 1), (m + n)))
        c1 = (cohorte[x + t].sum()) / cohorte[x]
        c2 = .5 * (cohorte[x + m] / cohorte[x]) + .5 * (cohorte[x + m + n] / cohorte[x])
        return (c2 + c1).round(7)
    elif kind == &#39;curtate&#39;:
        t = pd.Series(np.arange((m + 1), (m + n + 1)))
        c1 = (cohorte[x + t].sum()) / cohorte[x]
        return c1.round(7)
    else:
        print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="telma.SpainOperation.vida_media_temporal"><code class="name flex">
<span>def <span class="ident">vida_media_temporal</span></span>(<span>self, cohorte, x=25, n=5, kind='complete')</span>
</code></dt>
<dd>
<div class="desc"><p>Se trata ahora del nùmero de años que port término medio vivirà una persona de edad x en un intervalo de edades
(x, x+t).</p>
<p>:param cohorte: Funciòn cohorte (lx).</p>
<p>:param x: La edad del individuo.</p>
<p>:param n: La temporalidad a evaluar.</p>
<p>:param kind: El tipo "completo" o "abreviado"</p>
<p>:return: El valor de la vida media temporal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vida_media_temporal(self, cohorte, x=25, n=5, kind=&#39;complete&#39;):  ## pagina 50

    &#34;&#34;&#34;
    Se trata ahora del nùmero de años que port término medio vivirà una persona de edad x en un intervalo de edades
    (x, x+t).

    :param cohorte: Funciòn cohorte (lx).

    :param x: La edad del individuo.

    :param n: La temporalidad a evaluar.

    :param kind: El tipo &#34;completo&#34; o &#34;abreviado&#34;

    :return: El valor de la vida media temporal

    &#34;&#34;&#34;
    if kind == &#39;complete&#39;:
        t = pd.Series(np.arange(1, n))
        c1 = (cohorte[x + t].sum()) / cohorte[x]
        c2 = c1 + .5 + .5 * (cohorte[x + n] / cohorte[x])
        return c2.round(7)
    elif kind == &#39;curtate&#39;:
        t = pd.Series(np.arange(1, (n + 1)))
        c1 = (cohorte[x + t].sum()) / cohorte[x]
        return c1.round(7)
    else:
        print(&#39;Error! Kind parameter only accepts &#34;complete&#34; or &#34;curtate&#34;&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="telma.BiometricModel" href="#telma.BiometricModel">BiometricModel</a></code></h4>
<ul class="">
<li><code><a title="telma.BiometricModel.Lx" href="#telma.BiometricModel.Lx">Lx</a></code></li>
<li><code><a title="telma.BiometricModel.Tx" href="#telma.BiometricModel.Tx">Tx</a></code></li>
<li><code><a title="telma.BiometricModel.actuarialtable" href="#telma.BiometricModel.actuarialtable">actuarialtable</a></code></li>
<li><code><a title="telma.BiometricModel.actuarialtable2" href="#telma.BiometricModel.actuarialtable2">actuarialtable2</a></code></li>
<li><code><a title="telma.BiometricModel.central_rate_mortality" href="#telma.BiometricModel.central_rate_mortality">central_rate_mortality</a></code></li>
<li><code><a title="telma.BiometricModel.life_expectancy" href="#telma.BiometricModel.life_expectancy">life_expectancy</a></code></li>
<li><code><a title="telma.BiometricModel.omega" href="#telma.BiometricModel.omega">omega</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="telma.Datasets" href="#telma.Datasets">Datasets</a></code></h4>
<ul class="">
<li><code><a title="telma.Datasets.Italians_sim92" href="#telma.Datasets.Italians_sim92">Italians_sim92</a></code></li>
<li><code><a title="telma.Datasets.PER2020_Col_1er_orden" href="#telma.Datasets.PER2020_Col_1er_orden">PER2020_Col_1er_orden</a></code></li>
<li><code><a title="telma.Datasets.PER2020_Ind_2ndo_orden" href="#telma.Datasets.PER2020_Ind_2ndo_orden">PER2020_Ind_2ndo_orden</a></code></li>
<li><code><a title="telma.Datasets.Pasem2020" href="#telma.Datasets.Pasem2020">Pasem2020</a></code></li>
<li><code><a title="telma.Datasets.lifeTables" href="#telma.Datasets.lifeTables">lifeTables</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="telma.InsuranceBenefits" href="#telma.InsuranceBenefits">InsuranceBenefits</a></code></h4>
<ul class="">
<li><code><a title="telma.InsuranceBenefits.commutations" href="#telma.InsuranceBenefits.commutations">commutations</a></code></li>
<li><code><a title="telma.InsuranceBenefits.decreasing_annuity" href="#telma.InsuranceBenefits.decreasing_annuity">decreasing_annuity</a></code></li>
<li><code><a title="telma.InsuranceBenefits.deferred_annuity" href="#telma.InsuranceBenefits.deferred_annuity">deferred_annuity</a></code></li>
<li><code><a title="telma.InsuranceBenefits.endowment" href="#telma.InsuranceBenefits.endowment">endowment</a></code></li>
<li><code><a title="telma.InsuranceBenefits.increasing_annuity" href="#telma.InsuranceBenefits.increasing_annuity">increasing_annuity</a></code></li>
<li><code><a title="telma.InsuranceBenefits.increasing_lifeinsurance" href="#telma.InsuranceBenefits.increasing_lifeinsurance">increasing_lifeinsurance</a></code></li>
<li><code><a title="telma.InsuranceBenefits.pure_endowment" href="#telma.InsuranceBenefits.pure_endowment">pure_endowment</a></code></li>
<li><code><a title="telma.InsuranceBenefits.temporary_annuity" href="#telma.InsuranceBenefits.temporary_annuity">temporary_annuity</a></code></li>
<li><code><a title="telma.InsuranceBenefits.temporary_insurance" href="#telma.InsuranceBenefits.temporary_insurance">temporary_insurance</a></code></li>
<li><code><a title="telma.InsuranceBenefits.tincreasing_annuity" href="#telma.InsuranceBenefits.tincreasing_annuity">tincreasing_annuity</a></code></li>
<li><code><a title="telma.InsuranceBenefits.whole_life_insurance" href="#telma.InsuranceBenefits.whole_life_insurance">whole_life_insurance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="telma.MultipleLives" href="#telma.MultipleLives">MultipleLives</a></code></h4>
<ul class="two-column">
<li><code><a title="telma.MultipleLives.dissolution_no_ex" href="#telma.MultipleLives.dissolution_no_ex">dissolution_no_ex</a></code></li>
<li><code><a title="telma.MultipleLives.extinction" href="#telma.MultipleLives.extinction">extinction</a></code></li>
<li><code><a title="telma.MultipleLives.lifeplot_2" href="#telma.MultipleLives.lifeplot_2">lifeplot_2</a></code></li>
<li><code><a title="telma.MultipleLives.no_extinction" href="#telma.MultipleLives.no_extinction">no_extinction</a></code></li>
<li><code><a title="telma.MultipleLives.p_xy" href="#telma.MultipleLives.p_xy">p_xy</a></code></li>
<li><code><a title="telma.MultipleLives.q_xy" href="#telma.MultipleLives.q_xy">q_xy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="telma.OneLife" href="#telma.OneLife">OneLife</a></code></h4>
<ul class="">
<li><code><a title="telma.OneLife.d_x" href="#telma.OneLife.d_x">d_x</a></code></li>
<li><code><a title="telma.OneLife.deferred_mqx" href="#telma.OneLife.deferred_mqx">deferred_mqx</a></code></li>
<li><code><a title="telma.OneLife.lifeplot" href="#telma.OneLife.lifeplot">lifeplot</a></code></li>
<li><code><a title="telma.OneLife.p_x" href="#telma.OneLife.p_x">p_x</a></code></li>
<li><code><a title="telma.OneLife.q_x" href="#telma.OneLife.q_x">q_x</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="telma.SpainOperation" href="#telma.SpainOperation">SpainOperation</a></code></h4>
<ul class="">
<li><code><a title="telma.SpainOperation.renta_aritmetica" href="#telma.SpainOperation.renta_aritmetica">renta_aritmetica</a></code></li>
<li><code><a title="telma.SpainOperation.renta_aritmetica2" href="#telma.SpainOperation.renta_aritmetica2">renta_aritmetica2</a></code></li>
<li><code><a title="telma.SpainOperation.renta_constante" href="#telma.SpainOperation.renta_constante">renta_constante</a></code></li>
<li><code><a title="telma.SpainOperation.renta_geometrica" href="#telma.SpainOperation.renta_geometrica">renta_geometrica</a></code></li>
<li><code><a title="telma.SpainOperation.renta_geometrica2" href="#telma.SpainOperation.renta_geometrica2">renta_geometrica2</a></code></li>
<li><code><a title="telma.SpainOperation.seguro_fallecimiento" href="#telma.SpainOperation.seguro_fallecimiento">seguro_fallecimiento</a></code></li>
<li><code><a title="telma.SpainOperation.vida_media_diferida" href="#telma.SpainOperation.vida_media_diferida">vida_media_diferida</a></code></li>
<li><code><a title="telma.SpainOperation.vida_media_mixta" href="#telma.SpainOperation.vida_media_mixta">vida_media_mixta</a></code></li>
<li><code><a title="telma.SpainOperation.vida_media_temporal" href="#telma.SpainOperation.vida_media_temporal">vida_media_temporal</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>